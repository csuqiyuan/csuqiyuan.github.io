<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>权限管理-RBAC模型</title>
      <link href="/202009/quanxianguanlirbacmoxing/"/>
      <url>/202009/quanxianguanlirbacmoxing/</url>
      
        <content type="html"><![CDATA[<p>最近接触了一个 RBAC 权限管理系统的需求，将 RBAC 模型做一个总结。</p><p>在介绍 RBAC 之前，先说一下最简单最基础的权限控制模型，ACL 模型。</p><h2 id="访问控制列表（ACL-Access-Control-List）"><a href="#访问控制列表（ACL-Access-Control-List）" class="headerlink" title="访问控制列表（ACL : Access Control List）"></a>访问控制列表（ACL : Access Control List）</h2><p>ACL 即控制访问列表，它规定了资源可以被哪些用户进行操作。</p><p>在 ACL 模型下，权限管理是围绕“资源”来设定的，用户是直接与资源相关联的。</p><blockquote><p>资源：一般来说，可以是某个页面，也可以是某个 URI </p></blockquote><p>那么进行配置时，需要维护一个表，即“访问控制列表”，这个表中需要描述出“资源-用户”之间的关系，比如：</p><table><thead><tr><th align="center">id</th><th align="center">resource</th><th align="center">user_id</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">/test1</td><td align="center">10000</td></tr><tr><td align="center">2</td><td align="center">/test2</td><td align="center">10001</td></tr><tr><td align="center">3</td><td align="center">/test1</td><td align="center">10002</td></tr><tr><td align="center">4</td><td align="center">/test3</td><td align="center">10002</td></tr></tbody></table><p>上面的表只是一种 ACL 的表现形式，能够描述出“资源-用户”之间的关系的表结构都可以作为一个 ACL 表。</p><blockquote><ul><li>在用户请求某个资源时，需要先进行权限校验，在访问控制列表中查询是否有此资源与用户的对应关系，再返回用户是否拥有访问权限。</li><li>上表我配置了三个 uri 资源，三个用户，其中 10002 用户拥有 /test1，/test3 两个资源的请求权限。</li></ul></blockquote><p>这种权限管理模型的好处就是简单，方便，适合数据量小，数据相对静态的情况，比较容易维护。</p><p>缺点也比较明显，当资源和用户量大起来的时候，不便于权限管理，试想有这么一种场景：存在多个用户拥有多个关联的访问权限，那么在新增一个用户时，需要给这个用户配置指定多个权限，新增一个关联资源或修改某个资源时，需要为所有分配了这个资源的用户修改，麻烦。</p><blockquote><p>什么叫关联的访问权限？</p><p>比如一个系统中，新增往往伴随着编辑，那么这两个权限需要一起分配给用户。再比如某产品部门的所有人需要拥有自己产品的所有权限。</p></blockquote><h2 id="什么是-RBAC-？"><a href="#什么是-RBAC-？" class="headerlink" title="什么是 RBAC ？"></a>什么是 RBAC ？</h2><p>Role-Based Access Control，即，基于角色的权限控制。在这个模型中，用户不直接与权限相关联，而是通过角色关联用户与权限，角色是用户和权限之间的桥梁。</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1599306615/Others/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-RBAC%E6%A8%A1%E5%9E%8B/16d236221417437a_pgjr9u.jpg" alt=""></p><p>相比较 ACL 模式，这样的好处是扩展性强，对于权限的管理更加方便了，在上面我们提到的问题中，可以直接为用户赋予角色，或者修改时仅维护角色中的权限，无需维护每个用户下的权限。这种模式适用于用户数量、权限数量多的平台。</p><p>RBAC 又分为四类：RBAC0，RBAC1，RBAC2，RBAC3，其中 RBAC0 是最基础最简单的，其余皆为在 RBAC0 之上的升级。</p><h3 id="RBAC0-模型"><a href="#RBAC0-模型" class="headerlink" title="RBAC0 模型"></a>RBAC0 模型</h3><p>其实这种模型就是我们上面提到的，用户、角色、权限的多对多关系。</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1599307130/Others/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-RBAC%E6%A8%A1%E5%9E%8B/17010f6a1bd085bc_iqkksc.png" alt=""></p><p>在进行权限判断时，容易出现一种错误的实现方式，就是通过用户角色来判断用户执行权限，例如涨薪权限配置在 hr 角色下，在实现权限判断时，判断用户是否拥有 hr 角色。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> user.hasRole(<span class="string">&quot;hr&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的做法是错误的，如果后面需要让主管角色也有调薪权限，那么就该修改源代码了，麻烦不？正确做法应该是：先查询用户所拥有的角色，再根据角色查询用户拥有的权限，最后判断用户是否拥有某个的权限。</p><h3 id="RBAC1-模型"><a href="#RBAC1-模型" class="headerlink" title="RBAC1 模型"></a>RBAC1 模型</h3><p>RBAC1 模型又可以叫做“角色继承的 RBAC 模型”，引入了角色的继承概念，即角色具有上下级的关系，子角色可以继承父角色的所有权限。</p><blockquote><p> 角色继承的种类又分两种：</p><p>一般继承关系：要求角色继承关系是一个绝对偏序关系，允许角色间的多继承</p><p>受限继承关系：进一步要求角色继承关系是一个树结构，实现角色间的单继承</p></blockquote><p>这里我本人不太理解的一点是，不清楚角色之间的继承实现，网络上其他文章讲到这里也比较含糊不清，或者有多种说法。</p><p>一种说法是，权限小的角色继承权限大的角色，即权限大的角色是父角色，权限小的角色是子角色，是为了防止出现权限分配失误，子角色拥有父角色所没有的权限，所以子角色继承父角色的权限，只能在父角色权限下进行删减。</p><p>另一种说法相反，权限大的角色继承权限小的角色，即权限小的角色是父角色，权限大的角色是子角，例如一个公司中，主管是拥有员工所持有的权限的，所以主管继承员工的权限，不需要再手动为主管角色配置基础的员工权限，只要配置主管独有的权限即可。</p><p>两种说法都有其道理，可以看做是 RBAC1 的两个不同实现方式吧，根据需求来选用。</p><h3 id="RBAC2-模型"><a href="#RBAC2-模型" class="headerlink" title="RBAC2 模型"></a>RBAC2 模型</h3><p>RBAC2 模型又可以叫“约束控制的 RBAC 模型”，增加了对角色的一些限制：</p><ol><li><strong>互斥角色：</strong>互斥角色指权限相互制约的两个角色，同一用户只能分配到一组互斥角色中至多一个角色。比如运动员和裁判。案例：一个人不能既是运动员又是裁判。</li><li><strong>基数约束：</strong>一个角色被分配的用户数量受限，一个用户可拥有的角色数量受限，一个角色对应的访问权限数量受限。案例：某角色比较重要，比如超级管理员角色，需要规定角色数量防止重要权限泄露。</li><li><strong>先觉条件角色：</strong>用户想获得某上级角色，必须先获得其下一级角色。案例：先拥有副总经理权限，才能拥有总经理权限。</li><li><strong>运行时互斥：</strong>例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色，案例：同一个用户拥有多个角色，角色的权限有重叠，以较大权限为准。</li></ol><p>上面的约束也可以叫做“责任分离”，责任分离包括静态责任分离和动态责任分离。</p><ol><li>静态责任分离：用户无法同时被赋予互斥的角色</li><li>动态责任分离，用户可以被授予互斥的角色，但在一次会话中不能同时激活自身拥有的互斥的角色</li></ol><h3 id="RBAC3-模型"><a href="#RBAC3-模型" class="headerlink" title="RBAC3 模型"></a>RBAC3 模型</h3><p>又被称为“统一模型”，它包含了 RBAC1 和 RBAC2 的特性，既有角色分层又有角色约束。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>RBAC 模型不是一成不变的，上述几种只是较为常见的，它也可以有更多的实现方式，只要是基于“用户-角色-权限”这套思想实现的，都可以称之为 RBAC 模型，在实际使用中要根据需求来决定，比如 RBAC1 中两种不同的角色继承方式的实现。下面还有一些其他的类型。</p><h4 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h4><p>如果熟悉 linux 的同学，应该知道 linux 系统有用户和用户组的概念，也一定熟悉在使用 ll 命令或 chmod 命令为文件设置权限。见下图（请忽略它是个 mac 系统）</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1599309939/Others/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-RBAC%E6%A8%A1%E5%9E%8B/linux_uxpefw.png" alt=""></p><p>这里你大概就懂了，用户组的作用就是包含多个用户，只需要为用户组配置角色，就不用为这些用户单独配置角色了，进一步方便了权限的管理。比如新建一个开发者用户组，为开发者用户组配置了某些角色，将开发者添加进开发者用户组，所有开发者用户都会获得该用户组下的数据权限</p><p>用户组的形式也是多样的，除了上面提到的这种，更常见的是作为“组织”，比如总公司与分公司，不同地区的分公司组织拥有不同的角色权限，也可以是作为“职位”，不同职位的员工拥有不同的角色权限。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限管理,RBAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang Context 深入理解</title>
      <link href="/202008/golangcontextshenrulijie/"/>
      <url>/202008/golangcontextshenrulijie/</url>
      
        <content type="html"><![CDATA[<p>golang 中控制并发有几种经典方式，一种是 WaitGroup，一种是 channel ，一种是 Context。</p><p>我认为三者的功能并不冲突，分别负责了并发控制的两个部分；WaitGroup 的目的是为了让 main goroutine 等待其他 goroutine 执行结束，channel 是为了可以主动终止 goroutine，而 Context 的目的是为了管理多个、嵌套的 goroutine ，比如对多个 goroutine 同时执行关闭操作。三者可以分离使用，可以可以结合使用。</p><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>WaitGroup 是 sync 包下的一个类型，是一种并发控制的方式，其核心在于 Add、Done、Wait 三个方法的使用</p><p>比如我在 main 方法中创建了一个 goroutine 去做一些事情，go 会为 main 创建一个 goroutine，被称作 main goroutine ，但有个问题就是 main 函数结束时，它所创建的子 goroutine 也会结束，如何让 main goroutine 等待其他 goroutine 执行结束？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   wg.Add(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      handle1()</span><br><span class="line">      wg.Done()</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   wg.Add(<span class="number">1</span>)</span><br><span class="line">   <span class="keyword">go</span> handle2()</span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle1</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++ &#123;</span><br><span class="line">      log.Print(<span class="string">&quot;handle1&quot;</span>)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle2</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++ &#123;</span><br><span class="line">      log.Print(<span class="string">&quot;handle2&quot;</span>)</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是 WaitGroup 使用的一个例子，可以把 wg 相关的注销掉试试，handle 函数根本来不及输出就被终止了。</p><p>WaitGroup 的本质其实是一个计数器。</p><ul><li>Add 函数添加一个数字，这个数字要与你之后创建的 goroutine 数量一样。在上面例子我创建了两个 goroutine ，使用了两次 Add(1) ，其实与使用一次 Add(2) 的效果一样，为计数器加了对应的值。</li><li>Done 函数是用于将计数器减去一个值，里面调用的是 Add(-1)，可以把 Done 函数写在 defer 里，以防分支太多在退出前忘了调用 Done 。</li><li>Wait 函数是用于等待，当计数器不为 0 时，就会让 main goroutine 等待下去，直到所有的其他 goroutine 都执行完且调用 Done 了</li></ul><p>另外有没有注意到，两个 goroutine 使用 handle 函数的方式不一样，其实是为了表示两种使用 Done 函数的方式，如果 wg 定义的是 main 函数中的局部量，那么只能使用第一种方式，这里我定义为了全局量，那么就可以在 handle2 中使用 Done 函数。</p><p>但在实际业务中，可能存在这样一种场景，我们</p><h2 id="Channel-Select"><a href="#Channel-Select" class="headerlink" title="Channel + Select"></a>Channel + Select</h2><p>大部分情况下我们都是主动等待 goroutine 结束，但如果这个 goroutine 不会自己结束呢？使用 chan + select 可以主动终止一个 goroutine ，这种比较常用于 goroutine 无限循环用于做某件事的场景，当不再需要它做这件事时，传入 chan 一个值，将它终止。下面是一个例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> stop <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stop = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        handle1()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        handle2()</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    stop&lt;- <span class="literal">true</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">            fmt.Println(<span class="string">&quot;stop&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;handle2 do something&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我将 WaitGroup 结合在一起使用了，因为我想表示两个 goroutine ，handle1 在 5 秒后被终止，但 handle2 需要执行 10 秒，这样一种情况。handle1 就是被 chan + select 模式终止的例子。</p><p>但这样的方式也有局限性，如果很多 goroutine 都需要控制结束，而这些 goroutine 又创建了很多新的子 goroutine ，即嵌套 goroutine，通过定义很多乱七八糟的 chan 来实现么？那将会非常复杂。</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>中文名为“上下文”，是用来设置截止日期、同步信号、传递请求相关值的结构体。这是 go 语言中独特的设计，在其他语言中很少见到类似的概念。</p><p>个人觉得 Context 是上一节 chan + select 的加强版，因为二者有很多相似之处，比如都是使用了 chan 来传达终止命令，都是使用了 select 来监控 chan。</p><h3 id="Context-的使用"><a href="#Context-的使用" class="headerlink" title="Context 的使用"></a>Context 的使用</h3><p>context 包的核心是 Context 接口，里面提供了 Deadline、Done、Err、Value 四个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>Deadline 方法第一个返回值是截止时间，到了这个时间，Context 会自动发起取消请求；</li><li>Done 返回一个只读的 chan ，用于判断是否发起了取消请求，在 goroutine 中使用 select 来判断，其方式可以参考上一节内容；</li><li>Err 返回取消的错误原因，为什么被取消；</li><li>Value 方法可以获取 Context 上绑定的值，Context 中可以携带 key-value 对，用于传递信息，这个值一般是线程安全的。</li></ol><p>下面是一个使用例子，其中各种方法和函数的用法将在下一小节详细描述</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 返回一个 ctx ，一个取消函数 cancel，用于手动终止 goroutine</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> watch(ctx,<span class="string">&quot;【监控1】&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> watch(ctx,<span class="string">&quot;【监控2】&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> watch(ctx,<span class="string">&quot;【监控3】&quot;</span>)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;可以了，通知监控停止&quot;</span>)</span><br><span class="line">    cancel()</span><br><span class="line">    <span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(name,<span class="string">&quot;监控退出，停止了...&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(name,<span class="string">&quot;goroutine监控中...&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 WithCancel 创建了一个 ctx ，和其对应的取消方法 cancel，调用 cancel 可以使所有使用了此 ctx 的 goroutine 终止；</li><li>这里启动了三个监控 goroutine ，不断循环执行监控命令，当然没有进行真的监控，用打印代替；</li><li>监控函数中使用了无限循环和 select ，监控 Done 返回的 chan 是否有取消命令传来；</li><li>主函数中休眠 10 s，然后调用 cancel 函数，这时使用了 ctx 的三个 goroutine 都被结束了。</li></ol><blockquote><p>如果一个 goroutine 要使用 ctx ，ctx 作为参数传入时一般放在参数的第一位，这是约定俗成的</p><p>在一个 goroutine 中仍然可以创建子 goroutine 并把 ctx 传入，当调用了 cancle 函数，子 goroutine 也会被终止</p></blockquote><h3 id="Context-原理"><a href="#Context-原理" class="headerlink" title="Context 原理"></a>Context 原理</h3><p>先看看 goroutine 与 context 的设计思想。在 goroutine 构成的树形结构中对信号同步以减少资源浪费是 context 最大的作用，如图示意了 goroutine 构成的树形结构。</p><p>![](<a href="https://res.cloudinary.com/dkzvjuptx/image/upload/v1596974381/Golang/Golang">https://res.cloudinary.com/dkzvjuptx/image/upload/v1596974381/Golang/Golang</a> WaitGroup 与 Context 深入理解/golang-context-usage_tecqg7.png)</p><p>每个 context 会从顶层 goroutine 一层一层传递下去，当上层 goroutine 出现错误需要退出时，下层 goroutine 也会及时停止无用的工作，减少额外资源的消耗。</p><p>![](<a href="https://res.cloudinary.com/dkzvjuptx/image/upload/v1596974571/Golang/Golang">https://res.cloudinary.com/dkzvjuptx/image/upload/v1596974571/Golang/Golang</a> WaitGroup 与 Context 深入理解/golang-with-context_ynold4.png)</p><p>现在我们从源码层面上来解释一下 context 是如何做到这些的。</p><p>先来看看使用示例中 context.Background 是什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">    todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里已经实现了两个 context ，一个是 background ，一个是 todo，但其实它们两个本质上都是 emptyCtx 类型的，是一个不可取消，没设置截止时间，没携带任何值的 Context，只是名字上对其使用场景进行了区分。</p><ul><li>在 main 函数、初始化及测试代码中，background 可以作为 Context 树的最顶层，也就是根 context。</li><li>如果我们不知道该用什么 context 时，可以使用 todo，但很少能用到它。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 emptyCtx 的代码中可以看出，它实现了 Context 接口，但所有的方法都返回了 nil ，也就意味着 emptyCtx 没有任何特殊的功能。</p><p>有了根 context ，如何衍生出更多的子 context 呢？这里说到上面示例里提到的 WithCancel 函数了，总共有四种 With 函数，分别是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递一个父 context 作为参数，返回子 context，并返沪i一个 cancel 函数用来取消 context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="comment">// 和 WithCancel 差不多，但传入了一个截止时间参数，到达这个时间点会自动取消，也可以调用 cancel 函数进行取消</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="comment">// 与 WithDeadline 基本一样，这个表示超时取消，在多少时间后自动取消。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="comment">// 生成了一个绑定一个键值对的 context ，这个数据可以通过 Value 函数访问</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><p>WithTimeout 方法异常狡猾，直接复用了 WithDeadline 的全部逻辑，它的代码如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它调用了 WithDeadline 并把第二个参数设为当前时间 + timeout</p><p>其余几个函数分别对应了几个不同类型的 context ，而且它们都实现了另一个接口 canceler，With 函数返回的 cancel 函数就是实现了 canceler 接口的 cancel 函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="keyword">bool</span>, err error)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line"></span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// created lazily, closed by first cancel call</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      error                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    cancelCtx</span><br><span class="line">    timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">    deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line">    key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看结构体名称，基本都知道上述三个结构对应的哪个 With 函数了。</p><p>下面以 WithCancel 为例分析代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 将父 ctx 包装为 cancelCtx 结构体</span></span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">  <span class="comment">// 构建父子之间的关联，当父上下文被取消时，子上下文也会被取消</span></span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span> <span class="title">cancelCtx</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">  <span class="comment">// 父上下文不会触发取消信号</span></span><br><span class="line">    <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 监听父 ctx 是否被取消</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        child.cancel(<span class="literal">false</span>, parent.Err()) <span class="comment">// 父上下文已经被取消</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parentCancelCtx 判断 parent 是否是 cancelCtx 类型</span></span><br><span class="line">  <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">    <span class="comment">// 如果被取消，child 立即被取消；否则，child 被加入 parent 的 children 列表中 </span></span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 开启一个 goroutine 监听父、子上下文是否被取消</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">            <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">        c.mu.Unlock()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 向 done 传入取消信号，或者直接调用 close，也可以使关闭信号被捕获</span></span><br><span class="line">  <span class="comment">// closedchan 是一个初始化被关闭的 chan，关闭信号也算输出</span></span><br><span class="line">    c.err = err</span><br><span class="line">    <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">        c.done = closedchan</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(c.done)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 遍历当前上下文的子上下文列表，逐一关闭</span></span><br><span class="line">    <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">        child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    c.children = <span class="literal">nil</span></span><br><span class="line">    c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">        removeChild(c.Context, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更多使用示例"><a href="#更多使用示例" class="headerlink" title="更多使用示例"></a>更多使用示例</h3><p>通过 context.WithValue 来传值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">    valueCtx := context.WithValue(ctx, key, <span class="string">&quot;add value&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx)</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">    cancel()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="comment">//get value</span></span><br><span class="line">            fmt.Println(ctx.Value(key), <span class="string">&quot;is cancel&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//get value</span></span><br><span class="line">            fmt.Println(ctx.Value(key), <span class="string">&quot;int goroutine&quot;</span>)</span><br><span class="line"></span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>超时取消 context.WithTimeout</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;golang.org/x/net/context&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">            fmt.Println(<span class="string">&quot;Doing some work &quot;</span>, i)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we received the signal of cancelation in this channel</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;Cancel the context &quot;</span>, i)</span><br><span class="line">            <span class="keyword">return</span> ctx.Err()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">4</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hey, I&#x27;m going to do some work&quot;</span>)</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> work(ctx)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Finished. I&#x27;m going home&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>截止时间 取消 context.WithDeadline</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := time.Now().Add(<span class="number">1</span> * time.Second)</span><br><span class="line">    ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Even though ctx will be expired, it is good practice to call its</span></span><br><span class="line">    <span class="comment">// cancelation function in any case. Failure to do so may keep the</span></span><br><span class="line">    <span class="comment">// context and its parent alive longer than necessary.</span></span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;oversleep&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><p>其实就算看了上面的示例，也有点似懂非懂的感觉，因为示例都比较简单，都只有一层 goroutine ，没有多重的嵌套啊之类的场景。</p><p>下面说说我自己的理解。</p><p>前面提到过一个叫 goroutine 组成的树形结构，叫 goroutine 树，那么相对应的也有 context 树存在，但 context 树与 goroutine 树不一定刚好对应，只要没有生成子 context，那么这个树就没有增加新分支。</p><p>这几个 With 函数都是对参数传进来的 context 进行了封装生成了子上下文，那么 context 树就增加了新的分支，对这个新的分支可以看作一个新的树，这个子 context 可以看作新树的父 context，对这个子 context 进行 cancel 操作，这个分支下的所有 context 都会发出取消请求，但父 context 不会受到影响。</p><p>那么如果不进行封装，直接把 ctx 往更深层的 goroutine 传进去，那么事实上不管传入多深层的 goroutine，context 还是同一个，所以所有的 goroutine 事实上都共享这一个上下文，context 树没有新增分支，就不能对某几个 goroutine 进行操作了。</p><p>![](<a href="https://res.cloudinary.com/dkzvjuptx/image/upload/v1596987343/Golang/Golang">https://res.cloudinary.com/dkzvjuptx/image/upload/v1596987343/Golang/Golang</a> WaitGroup 与 Context 深入理解/goroutine_gruvna.png)</p><p>结合上图解释一下，如果从 goroutine 0 开始，都只用了一个初始的 ctx ，之后都没有进行 With 函数的调用，那么结果就是，你只能把 goroutine 0 到 goroutine 7 所有的 goroutine 终止掉，而不能只终止 goroutine 1 和 goroutine 4 这个分支。</p><p>如果你在 goroutine 1、2、3 上都调用了 WithCancel 函数，那么 context 就有了三个分支，你可以选择调用根 context ，即 goroutine 0 的上下文的 cancel 来终止所有 goroutine，也可以选择终止某个子 context 分支上的所有 goroutine，比如你可以只终止 goroutine 1、4 这条分支，或者终止 goroutine 3、6、7 这条分支，但其他分支和根上下文的 goroutine 不受影响。</p><p>如果还需要更精细的控制，还可以在更深层继承上一层的上下文，构造更深层的子上下文。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 新特性——Optional  使用详解</title>
      <link href="/202002/java8xintexing/"/>
      <url>/202002/java8xintexing/</url>
      
        <content type="html"><![CDATA[<p>最近在被 code review 的时候，组里大佬对我代码中几处使用 if 判断对象是否为空的地方提了一句话：</p><p>“使用 Optional ，能不用 null 就不用 null”</p><p>Java 8 的发布已经有很长时间了，其新特性几乎是面试必问，老生常谈的问题，但我在实际开发中却很少用到，也很少见人用到，甚至在某程序员社区看到有人发帖称“老板禁止我用 Stream ，说怕别人不会用…”。</p><p>之前在朋友圈夸过，我们组的代码是我见过最简洁规范的 Java 代码，能用一行代码解决的事情绝不用两行代码。虽然我能随口说出Java 8 的新特性，但使用经验实在太少，用句学生时代的老话说：“没有把书本上的知识变成自己的知识”。于是我在网上查阅了关于 Optional 使用的资料。</p><h2 id="Optional-的作用"><a href="#Optional-的作用" class="headerlink" title="Optional 的作用"></a>Optional 的作用</h2><p>Optional 类是一个可以包含可选值的包装类，也可以理解为一个包含可选对象的容器。它所包含的对象可以为空，是实现 Java 函数式编程的强劲一步。</p><p>但 Optional 类主要解决的问题是每个程序员都非常熟悉的，臭名昭著的空指针异常（NullPointerException）——这是网上的说法，就我的感觉来讲，Optional 并没有解决空指针异常，而是简化里对于空指针异常的处理过程。</p><p>在没有 Optional 时为了解决空指针异常，常常要在访问每一个对象前使用逻辑判断语句对值做检查，下面是个例子：</p><p>假设有下面三个类，现在拥有一个 User 对象，想获取 isoCode 值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Country country;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Country <span class="title">getCountry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> country;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String isoCode;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIsoCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isoCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是两种方案，方案一是不做任何处理，极有可能报 NullPointerException，方案二是使用逻辑判断语句做检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案一，容易出现 NullPointerException</span></span><br><span class="line">String isocode = user.getAddress().getCountry().getIsocode().toUpperCase();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案二</span></span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Address address = user.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (address != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Country country = address.getCountry();</span><br><span class="line">        <span class="keyword">if</span> (country != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String isocode = country.getIsocode();</span><br><span class="line">            <span class="keyword">if</span> (isocode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                isocode = isocode.toUpperCase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到方案二为排除 NullPointerException 而写的代码很低效，如果需要对 对象 为空的情况做处理，那么代码将更加冗长，难以维护。讲到这里想到了一个经典笑话——特工说“我拿到了敌军的系统代码，但只有最后几千行”，指挥官大喜：“快让我看看”，结果只见：“…… }}}}}}}}}}}}}}}}}}}}}}}}} ……”。</p><p>我们先来看看 Optional 的常用方法。</p><h2 id="Optional-常用方法详解"><a href="#Optional-常用方法详解" class="headerlink" title="Optional 常用方法详解"></a>Optional 常用方法详解</h2><table><thead><tr><th></th><th><strong>方法及描述</strong></th></tr></thead><tbody><tr><td>1</td><td><strong>Optional()</strong><br>私有构造方法，被 empty() 方法用于创建空 Optional 对象</td></tr><tr><td>2</td><td><strong>Optional(T value)</strong><br>私有构造方法。被 of() 方法用于创建带值的Optional 对象</td></tr><tr><td>3</td><td><strong>static&lt;T&gt; Optional<T> empty()</strong><br/>返回空的 Optional 实例</td></tr><tr><td>4</td><td><strong>static &lt;T&gt; Optional<T> of(T value)</strong><br/>返回一个指定非null值的Optional</td></tr><tr><td>5</td><td><strong>static &lt;T&gt; Optional<T> ofNullable(T value)</strong><br/>如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional</td></tr><tr><td>6</td><td><strong>T get()</strong><br/>如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException</td></tr><tr><td>7</td><td><strong>boolean isPresent()</strong><br/>如果值存在则方法会返回true，否则返回 false</td></tr><tr><td>8</td><td><strong>void ifPresent(Consumer&lt;? super T&gt; consumer)</strong><br/>如果值存在则使用该值调用 consumer , 否则不做任何事情</td></tr><tr><td>9</td><td><strong>T orElse(T other)</strong><br/>如果存在该值，返回值， 否则返回 other</td></tr><tr><td>10</td><td><strong>T orElseGet(Supplier&lt;? extends T&gt; other)</strong><br/>如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果</td></tr><tr><td>11</td><td><strong>&lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</strong><br/>如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常</td></tr><tr><td>12</td><td><strong>Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</strong><br>如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional</td></tr><tr><td>13</td><td><strong>&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt;</strong><br>如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional</td></tr><tr><td>14</td><td><strong>&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</strong><br>如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</td></tr></tbody></table><p>除去以上方法，Optional 类还包含 equals、hashCode、toString 等重写 Object 类的方法。</p><h2 id="常用方法使用"><a href="#常用方法使用" class="headerlink" title="常用方法使用"></a>常用方法使用</h2><p><strong>empty() 和 get()</strong></p><p>empty() 用于创建一个空的 Optional 容器，看看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有构造方法、私有静态对象、公有静态方法，这里使用了饿汉式单例模式。</p><p>get() 方法用于取出 Optional 容器中的对象，但如果对象为空，将报 NoSuchElementException 异常，原因可见源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>of() 和 ofNullable()</strong></p><p>静态方法，都是用于创建包含值的 Optional 容器，区别就是，of() 值不能为 null ，否则报 NullPointerException ，ofNullable() 可以传 null 。因此使用 of() 时应明确对象不能为 null ，如果对象可能为 null，应使用 ofNullable() 。另外，这里已经不是使用单例模式创建的对象了，见源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，每次调用这两者，都会新创建一个对象。ofNullable() 进行了一次判断，跟据传入值是否为空，决定使用 empty() 或 of() 方法。</p><p><strong>isPresent() 和 ifPresent(Consumer&lt;? super T&gt; consumer)</strong></p><p>从这里开始，便是 Optional 使用的关键了。</p><p>isPresent() 用于判断 Optional 内是否为空，如果不为空返回 true，为空返回 false，和 List 中的 isEmpty() 恰好相反。</p><p>ifPresent(Consumer&lt;? super T&gt; consumer) 除了判断是否为空外，还传入了一个 Consumer (消费者)函数式接口，如果不为空，会执行 Lambda 表达式。Consumer 是 Java 定义好的函数式接口，与 Lambda 表达式配合，可以实现函数式编程。Consumer 消费者接口接收一个参数，返回值为 void 。</p><p>直接贴使用代码，感兴趣的可以自己查阅源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="comment">// getString() 是返回一个 String 值的假想方法，这个值可为 null</span></span><br><span class="line">Optional&lt;String&gt; opt = Optional.ofNullable(getString());</span><br><span class="line"><span class="keyword">if</span>(opt.isPresent())&#123;</span><br><span class="line">    System.out.println(opt.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line">opt.ifPresent(s -&gt; System.out.println(s));</span><br><span class="line"><span class="comment">// 亦可写作 opt.ifPresent(System.out::println);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line">String str = getString();</span><br><span class="line"><span class="keyword">if</span>(str != <span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，输出 String 并不会报 NullPointerException，这只是个简单的例子展示，传入 Optional 的类型可以变为任何一个对象，对其做的操作也不仅局限于输出。可以看到 示例二 明显更简洁和美观。</p><p><strong>orElse(T other)、orElseGet(Supplier&lt;? extends T&gt; other) 和 orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</strong></p><p>orElse 方法的用法是，当容器内不为空时，返回容器内的对象，否则返回参数传入的对象；而 orElseGet 的用法是：当容器不为空时，返回容器内的对象，否则执行传入的 Supplier (供应者)函数式接口。Supplier 供应者接口不接收参数，返回一个 T 泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假如有如下场景。</span></span><br><span class="line"><span class="comment"> * 通过 getUser() 获取一个 User 对象，可能为空。如果为空时，需要返回一个默认对象。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统解决方案</span></span><br><span class="line">User user = getUser();</span><br><span class="line">User result ;</span><br><span class="line"><span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">    result = <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    result = user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// orElse 示例</span></span><br><span class="line">Optional&lt;User&gt; opt = Optional.ofNullable(getUser());</span><br><span class="line">User result = opt.orElse(<span class="keyword">new</span> User(<span class="string">&quot;...&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment">// orElseGet 示例</span></span><br><span class="line">Optional&lt;User&gt; opt = Optional.ofNullable(getUser());</span><br><span class="line">User result = opt.orElseGet(() -&gt; <span class="keyword">new</span> User(<span class="string">&quot;...&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>可以看到，使用 Optional 的方案代码简洁许多。orElse 和 orElseGet 的区别似乎仅仅是一个传入对象，一个传入函数式接口（Lambda 表达式）。除此之外，它们的区别还在于：orElse 不管存不存在值，后面的创建新对象的过程是必然发生的；而 orElseGet 就仅仅在值不存在时触发创建新对象的代码。后者相对来说更节省性能。</p><p>orElseThrow 则会在值为空时抛出异常，可以指定抛出的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统解决方案</span></span><br><span class="line">User user = getUser();</span><br><span class="line"><span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// orElseThrow 方案</span></span><br><span class="line">Optional&lt;User&gt; opt = Optional.ofNullable(getUser());</span><br><span class="line">opt.orElseThrow(() -&gt; <span class="keyword">new</span> IllegalArgumentException());</span><br><span class="line"><span class="comment">// 进一步简化</span></span><br><span class="line">opt.orElseThrow(IllegalArgumentException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p><strong>map(Function&lt;? super T, ? extends U&gt; 和 flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</strong></p><p>map 和 flatMap 都传入了 Function 函数式接口，即接收一个参数，有一个返回值。map 和 flatMap 都可以把当前 Optional 对象转化为其他类型的 Optional 对象，但实现方式略有不同。</p><p>map 是将一个对象包装成 Optional ，而 flatMap 直接返回了包含对象的 Optional 。这点从接口函数的参数定义中可以看出：? extends U 和 Optional&lt;U&gt;&gt; mapper; 即 map 函数式接口返回的是一个普通对象，flatMap 函数式接口返回的是一个 Optional 对象。</p><p>这两个方法可以对返回值进行链式调用。</p><p>下面将我们最初例子使用 Optional 重写一遍最初获取 isoCode 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">        address = <span class="keyword">new</span> Address();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Country country;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">()</span></span>&#123;</span><br><span class="line">        country = <span class="keyword">new</span> Country(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Country <span class="title">getCountry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String isoCode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Country</span><span class="params">(String isoCode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isoCode = isoCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIsoCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isoCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 经典解决方案</span></span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Address address = user.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (address != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Country country = address.getCountry();</span><br><span class="line">        <span class="keyword">if</span> (country != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String isocode = country.getIsocode();</span><br><span class="line">            <span class="keyword">if</span> (isoCode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                isoCode = isocode.toUpperCase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(isoCode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optional map 方案：</span></span><br><span class="line">Optional&lt;User&gt; opt = Optional.ofNullable(user);</span><br><span class="line">String isoCode = opt.map(u -&gt; u.getAddress())</span><br><span class="line">    .map(a -&gt; a.getCountry()) <span class="comment">// 可使用方法引用简化 map(User::getContry)</span></span><br><span class="line">    .map(c -&gt; c.getIsoCode())</span><br><span class="line">    .orElse(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">    .toLowerCase();</span><br><span class="line">System.out.println(isoCode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optional flatMap 方案：需要对对象做一些修改</span></span><br><span class="line"><span class="comment">// getAddress() 和 getCountry() 方法修改如下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Address&gt; <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Country&gt; <span class="title">getCountry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(country);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flatMap 解决方案如下</span></span><br><span class="line">Optional&lt;User&gt; opt = Optional.ofNullable(user);</span><br><span class="line">String isoCode = opt.flatMap(u -&gt; u.getAddress())</span><br><span class="line">    .flatMap(a -&gt; a.getCountry())</span><br><span class="line">    .map(c -&gt; c.getIsoCode())</span><br><span class="line">    .orElse(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">    .toLowerCase();</span><br><span class="line">System.out.println(isoCode);</span><br></pre></td></tr></table></figure><p>如果调用链过程中有任何一个对象为空，将返回默认值 “default”，过程简洁明了。也可以使用方法引用进一步简化这个过程。</p><p><strong>filter(Predicate&lt;? super T&gt; predicate)</strong></p><p>filter() 接受一个 Predicate 函数式接口参数，这个接口接收一个参数，返回 boolean 值。如果这个参数返回的结果为 true，filter 函数返回这个 Optional 对象本身，否则返回一个空的 Optional 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="string">&quot;anna@gmail.com&quot;</span>, <span class="string">&quot;1234&quot;</span>);</span><br><span class="line">Optional&lt;User&gt; result = Optional.ofNullable(user)</span><br><span class="line">    .filter(u -&gt; u.getEmail() != <span class="keyword">null</span> &amp;&amp; u.getEmail().contains(<span class="string">&quot;@&quot;</span>));</span><br><span class="line">System.out.println(result.get().getEmail());</span><br></pre></td></tr></table></figure><p>filter 函数可以用于过滤某些不符合要求的参数。</p><h2 id="Java-9-的-Optional-新特性"><a href="#Java-9-的-Optional-新特性" class="headerlink" title="Java 9 的 Optional 新特性"></a>Java 9 的 Optional 新特性</h2><p>新增了三个方法：or()、ifPresentOrElse()、stream()。</p><p><strong>后面我会持续更新这三个方法的使用，以及 Lambda 表达式、函数式接口、方法引用等特性的用法</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java 8 新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端发展简史</title>
      <link href="/202001/qianduanfazhanjianshi/"/>
      <url>/202001/qianduanfazhanjianshi/</url>
      
        <content type="html"><![CDATA[<p>在知乎上闲逛，偶尔看到一篇文章讲前端发展简史的，感觉写的还蛮不错。我虽然也写过一段时间前端，但对前端的发展历史并没有什么了解，总是盲目地进行前后端分离和 MVVC，不知道服务端渲染和客户端渲染的优劣，不明白 node 中间层存在的意义，反正大家都这么做，我也就跟着这么做，这篇文章以及其姊妹篇 “Node.js 换个角度看世界” 对前端的整体发展历程和后面客户端/服务端渲染之争有了较完整的描述。经作者本人同意，转载到自己的博客上。</p><p>原文<a href="https://zhuanlan.zhihu.com/p/91842778">点击这里</a></p><p>下面是文章内容：</p><h2 id="什么是前端"><a href="#什么是前端" class="headerlink" title="什么是前端"></a>什么是前端</h2><p>回答这个问题之前，我想起了一道非常经典的前端面试题：“从输入URL到页面呈现在你面前到底发生了什么？”这个题目可以回答的很简单，但仔细思考，也可以回答得很深，这个过程涉及的东西很多。先看一张图：</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823581/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/1_xmyqpd.jpg" alt=""> 简单说就是</p><ol><li>DNS (Domain Name System) 解析</li><li>TCP (Transmission Control Protocol) 链接</li><li>HTTP (HyperText Transfer Protocol) 请求</li><li>HTTP 响应</li><li>HTML解析 &amp; CSS渲染</li><li>JS 解析执行</li></ol><p>为什么提这个呢，因为这是一整个web服务生命周期的全过程，而在最早的时候是根本没有前端或者后端的概念的，当时就是用 Dreamweaver 写 <code>html</code> 静态页面，然后部署到一台电脑的 IIS (Internet Information Services) 上，当请求这个页面时，返回这个 <code>html</code> 文件。再后面一点，服务端变得复杂了一些，<code>html</code> 页面开始使用各种模板来写，譬如 <code>Java</code> 系列的 <code>FreeMarker</code>，还有 <code>ASP</code> 、 <code>PHP</code> 等等。 此时，前后端开发是一体的，最多也就是模板的编写算是最初的前端范畴，但那个时候，这个活儿往往都是现在的后端开发去干的。</p><p>下面是一个比较典型的 <code>PHP</code> 的模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Car &#123;&#123; $car-&gt;id &#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Car &#123;&#123; $car-&gt;id &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Make: &#123;&#123; $car-&gt;make &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Model: &#123;&#123; $car-&gt;model &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Produced on: &#123;&#123; $car-&gt;produced_on &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>随着 2005年 Ajax (<code>Asynchronous JavaScript and XML</code>) 的诞生，彻底得改变了这一切，<code>JS</code> 脚本可以独立向服务器请求数据，拿到数据后，进行处理并更新网页，这个过程中，后端只负责提供数据，其他事情都由前端来做，就是从这个时期开始，前端逐渐变得复杂，也是从在这个时期开始，设计师和后端开发已经开始放弃前端了，开发的岗位角色悄悄地发生了变化：</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823581/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/2_ybopzw.jpg" alt=""></p><p>聊到现在，什么是前端的问题应该呼之欲出了:</p><ul><li><strong>前端： 针对浏览器的开发，代码在浏览器中运行</strong></li><li><strong>后端： 针对服务器的开发，代码在服务器中运行</strong></li></ul><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823581/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/3_lzotkq.jpg" alt=""></p><p>可以说 Ajax 的出现是前端岗位出现的转折点，但并不是前端的起点，前端的起点，我们稍后聊 <code>JavaScript</code> 的历史会聊到。</p><p>既然前端是针对浏览器的开发，那一个页面呈现出来，在浏览器里做了什么呢？</p><p>浏览器收到服务器响应的 <code>HTTP</code> 报文后，边解析边渲染。首先浏览器解析 <code>html</code> 文件构建 <code>DOM</code> 树，然后解析 <code>CSS</code> 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。除了表现之外，我们还需要与页面交互，所以离不开 <code>JS</code>，而 <code>JS</code> 的解析和运行是由浏览器中的 <code>JS</code> 引擎来完成，最有名的就是2008年由 Google 发布的 V8。</p><p>所以，跑在浏览器的代码无外乎这三种：<strong><code>HTML</code> + <code>CSS</code> + <code>JS</code></strong></p><p><strong><code>HTML(HyperText Markup Language)</code></strong> 全称是超文本标记语言，它不是一门编程语言，而是一种用来告知浏览器如何组织页面的标记语言。它由一系列的元素（elements）组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823579/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/4_w0o4q9.jpg" alt=""></p><p> 我们在浏览器中任意打开一个页面的源码，都会看到类似如下的内容： </p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823578/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/5_drtyp8.jpg" alt=""></p><p> <strong><code>CSS(Cascading Style Sheets)</code></strong> 全称是层叠样式表，它是用来样式化和排版网页的 —— 例如更改网页内容的字体、颜色、大小和间距，将内容分割成多列或者加入动画以及别的装饰型效果。它通过选择器选中上面提到的 <code>HTML</code> 元素，然后为选中的元素添加颜色，间距等样式。如下所示： </p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823578/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/6_he75ca.jpg" alt=""></p><p> 每一个有追求有品味的页面，都在借 <code>CSS</code> 给浏览者说一句话：”<strong>我怎么这么好看！</strong>“ </p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823579/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/7_xtebla.jpg" alt=""></p><p> <strong><code>JS(JavaScript)</code></strong> 是一种具有函数优先的轻量级、解释型编程语言。它因互联网而生，紧跟着浏览器的出现而问世。<strong>它是一门计算机语言</strong>，随着前端的迅猛发展，它已经不像刚开始出现时那样，只是为了做了一些页面的校验，已经成了构建企业级应用的重要语言之一，目前在全球范围的使用情况排名第三。 </p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823579/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/8_elu07u.jpg" alt=""></p><p> 如果用一个人来作比喻网页的话，<code>HTML</code> 就是一个人的骨骼， <code>CSS</code> 就是一个人的血肉，而 <strong><code>JS</code> 则是一个人的灵魂</strong>！ </p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823579/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/9_zf0gpx.jpg" alt=""></p><blockquote><p>当然随着V8的诞生以及Node的问世，让 <code>JavaScript</code> 可以跑在非浏览器中，进一步拓展了前端的范畴，下一节我们聊这方面的事情。</p></blockquote><p><strong>前端开发工程师</strong> 是近十年随着前端发展才真正开始受到重视的一个新兴职业。刚才我们提到前端的三个组成部分：<strong><code>HTML</code> + <code>CSS</code> + <code>JS</code></strong>，这三个部分看起来听起来都感觉很简单，也正因为如此，前端开发领域有很多自学成“才”的同行，我甚至在校招面试时听到候选人说是因为觉得后端太难，其它岗位面试通不过才选择前端的。确实，前端开发的入门门槛低，与后端语言先慢后快的学习曲线相比，前端开发的学习曲线是先快后慢，后面的学习曲线越来越陡峭，每前进一步都很难，导致大多数前端开发都停留在初级阶段。</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823579/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/10_ip2x1m.jpg" alt=""></p><p>目前，前端开发工程师主要分布在这些地方：</p><ul><li>大公司</li><li>互联网公司</li><li>传统行业</li><li>创业公司</li><li>自由职业</li><li>外包、自己接项目</li><li>行业大牛</li></ul><p>创业公司的特点是开发团队人数不多，但有一个共同点：技术leader是从大公司历练出来的，因为船小好掉头的原因，往往技术的实效性要比大型互联网公司好一些。 而大型互联网公司的特点是体系、流程很完善(久经考验的)，服务的用户、体量都非常大，部门人数多、协同开发的机制很完善，内部不缺比你牛逼的人，身边的同事都不是特别菜的，可能最菜的就是你自己。</p><h2 id="JavaScript-语言的历史"><a href="#JavaScript-语言的历史" class="headerlink" title="JavaScript 语言的历史"></a>JavaScript 语言的历史</h2><p>JS 作为网页的灵魂，它是前端开发中最重要的一部分，所以接下来我们来看看 JavaScript 作为一门计算机语言是怎么诞生的，又经历了怎么样的发展。</p><p><strong>1990年12月</strong>，欧洲核子研究中心（CERN）的科学家 Tim Berners-Lee 发明了万维网（World Wide Web），今年的3月12日，欧洲核子研究中心还举办了系列活动，庆祝万维网发明三十周年。当时的网页还只能在操作系统的终端里浏览，也就是说只能使用命令行操作，网页内容都是在字符窗口中显示，这当然非常不方便。</p><blockquote><p>1994年5月中科院高能物理研究所计算中心的许榕生研究员去 CERN 参加了由380人参加的第一届国际 WWW 大会。会后，他带领一批年轻人很快在高能所计算中心的一台 PC 机上用 Linux 创建了中国第一个 WWW 服务器，并推出第一个网站 <code>www.ihep.ac.cn</code> (这个域名现在还在使用) 和英文网页（IHEP/China Home Page），该网站成为当时亚洲少数几个网站之一。</p></blockquote><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823580/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/11_elznla.jpg" alt=""></p><p> <strong>1992年底</strong>，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做 Mosaic。这是人类历史上第一个浏览器，从此网页可以在图形界面的窗口浏览。Mosaic 是后来大家耳熟能详的网景浏览器（Netscape Navigator）的前身。那时候还没有 Ajax，所以用户每次操作，都会重新加载整个页面，于是 Netscape 公司很快就发现一个问题，如果用户还没有输入内容，就点了“发送”摁钮，服务器发现后把整个页面重新返回给客户端，仅仅只是在页面中添加了一个错误提示，那个时代网速很慢上网很贵，到服务器才发现这一点很明显太晚了，最好能在用户发出数据之前，就告诉用户“请填写内容”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。 </p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823579/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/12_xbtzqn.jpg" alt=""></p><p><strong>1995年4月</strong>，Netscape 公司雇佣了程序员 Brendan Eich 开发这种网页脚本语言，Brendan Eich 只用了10天，就设计完成了这种语言的第一版，最初名字叫做 Mocha，1995年9月改为 LiveScript。12月，Netscape 公司与 Sun 公司（Java 语言的发明者和所有者）达成协议，后者允许将这种语言叫做 JavaScript。这样一来，Netscape 公司可以借助 Java 语言的声势，而 Sun 公司则将自己的影响力扩展到了浏览器。实际上 JavaScript 与 Java 没啥太大关系！</p><p><strong>1996年8月</strong>，微软模仿 JavaScript 开发了一种相近的语言，取名为JScript（JavaScript 是 Netscape 的注册商标，微软不能用），首先内置于IE 3.0。Netscape 公司面临丧失浏览器脚本语言的主导权的局面。于是，Netscape 公司在1996年11月决定将 JavaScript 提交给国际标准化组织 ECMA (European Computer Manufacturers Association), 希望 JavaScript 能够成为国际标准，以此抵抗微软。</p><p><strong>1997年7月</strong>，ECMA 组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。之所以不叫 JavaScript，一方面是由于商标的关系，Java 是 Sun 公司的商标，根据一份授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 已经被 Netscape 公司注册为商标，另一方面也是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。</p><p>接下来的两年，连续发布了 ECMAScript 2.0（1998 年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。<strong>直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法</strong>。</p><p><strong>2000年</strong>，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6 继承了。因此，ES6 制定的起点其实是 2000 年。为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3 做了彻底升级（也就是现在的ES6），引来了以 Yahoo、Microsoft、Google 为首的大公司的强烈反对，ECMA 开会决定，中止 ECMAScript 4.0 的开发。</p><blockquote><p>只有 JavaScript 的创造者 Brendan Eich 所在的 Mozilla 公司 坚持ES4的草案，有时候要创点新真得不容易！</p></blockquote><p><strong>2015年6月</strong>，ECMAScript 6 正式发布，并且更名为“ECMAScript 2015”。虽然从ES3之后，陆续发了 ES5 以及 ES5.1，但都是涉及现有功能改善的一小部分。</p><p>对于前端开发来说，接受并熟悉 ES6 是比较困难的，毕竟当年 Google 就接受不了，何况 ES6 是集过去15年的精华于一身。</p><h2 id="Web开发技术演进"><a href="#Web开发技术演进" class="headerlink" title="Web开发技术演进"></a>Web开发技术演进</h2><p>聊完 JavaScript 的历史，我们可以看到，它并不随前端的发展呈正相关，因为它在很长一段时间，并没有什么变化。所以接下来聊聊前端技术演进的历史，看看这些年前端都发生了什么。</p><h3 id="Web-2-0"><a href="#Web-2-0" class="headerlink" title="Web 2.0"></a>Web 2.0</h3><p>前面提到的 2005 年诞生的 Ajax，促进了前后端的分离。其实是在这一年谷歌发布了测试版本的谷歌地图，并在这个项目大量运用让网页透过 Javascript 以 XML 格式来回传数据、达到异步更新网页内容的技术，这在当时是一个跨时代的壮举，让用户终于有机会看到不需要刷新整个页面就可以更新状态的地图，我们也看到了异步操作是如何给网站用户带来良好体验的。</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823580/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/13_krlwhd.jpg" alt=""></p><p>不夸张的说，这一年算得上是 Web 开发技术发展的元年。Web也从 1.0 的时代，步入 2.0 的时代。</p><h3 id="MVC-model-view-controller"><a href="#MVC-model-view-controller" class="headerlink" title="MVC (model-view-controller)"></a>MVC (model-view-controller)</h3><p>前端可以通过 Ajax 获取数据，因此也就有了处理数据的需求，于是就促使了前端 MVC 的诞生。</p><p>我第一个前端项目就是使用 MVC 模式做的，使用的是 ExtJs，它曾经是一个很好的企业级 Web 富客户端应用开发平台，它做出来的页面效果特别酷炫。如下图所示：</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823579/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/14_dcg5oi.jpg" alt=""></p><p>而我在做这个项目时就应用了 MVC 的模式。</p><ul><li>视图（View）：用户界面</li><li>控制器（Controller）：业务逻辑</li><li>模型（Model）：数据模型</li></ul><p>View 作为用户界面，发送指令给 Controller，Controller 要求 Model 改变状态，同时 Model 把更新过的数据发送给 View 反馈给用户。</p><p>MVC 模型最核心的一点就是 <strong>所有通信都是单向的</strong></p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823580/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/15_t6iyos.jpg" alt=""></p><p>其实生活当中，MVC 的设计思想很多地方都有所体现，以家用微波炉为例，可以将它也理解成三层结构。微波炉的外观以及上面的操作摁钮就是”视图层”（view），而其内部的微波产生装置磁控管则是”数据层”（Model），这里的”数据”可以理解成”核心功能”。把操作摁钮的指令转化为对磁控管的操作则是由“控制器层”的电路板来实现的。</p><p>如果现在要给微波炉更换一个新潮的外壳，或者更换一个更大功率的磁控管，完全可以在不更改其他层的情况下实现。<strong>每一层都是独立的，这就是 MVC 模式的最大优势。</strong></p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823580/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/16_rsoizp.jpg" alt=""></p><p>在这个阶段的后期，前端逐渐开始有了一点工程化的影子，并且开始受 CommonJS 的影响，有了模块化编程的概念，诞生了相应的 CMD 和 AMD 的规范。开始有了构建工具 Grunt/Gulp，开始有了编码的规范 JsLint。</p><h3 id="MVVM-Model-View-ViewModel"><a href="#MVVM-Model-View-ViewModel" class="headerlink" title="MVVM (Model-View-ViewModel)"></a>MVVM (Model-View-ViewModel)</h3><p>MVVM 同样是一种软件架构模式，它是在 MVC 的基础上演进过来的，去掉了 MVC 中的 Controller，增加了数据的双向绑定。</p><p>最有代表性的框架就是 Google 公司推出的 Angular， 它的风格属于 HTML 语言的增强，核心概念就是数据双向绑定。</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823580/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/17_twic92.jpg" alt=""></p><p> Vue也可以算是 MVVM 模型，虽然它没有完全遵守 MVVM 的设计，但受到了 MVVM 的启发，在最开始的时候也是双向数据绑定，并且一直使用 vm 表示 View-Model。就以 Vue为例，简单看下 MVVM 的思想。 </p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823580/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/18_zsps0r.jpg" alt=""></p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823580/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/19_xsuv93.jpg" alt=""></p><h3 id="SPA-single-page-application"><a href="#SPA-single-page-application" class="headerlink" title="SPA (single-page application)"></a>SPA (single-page application)</h3><p>SPA 是单页应用的意思，它是区分传统模式而言的。我们一开始就探讨过从输入URL到页面呈现在我们面前的过程，也熟悉了 <code>HTML</code> 、 <code>CSS</code> 和 <code>JS</code>。现在换个角度来看这个过程：</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823580/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/20_zahijm.jpg" alt=""></p><p>当客户端发起页面请求后，后端收到请求，然后取出数据库中的数据，组装好 <code>HTML</code>，然后返回 <code>HTML</code> 、 <code>CSS</code> 和 <code>JS</code>。有了 Ajax 后，我们在当前页面可以重新获取数据，并更新页面内容。但当我们切换页面，也就是有页面跳转时，整个过程会从头再来一次。精益求精的前端开发者们这个时候就在考虑，既然 Ajax 可以在当前页面获取数据并随时更新当前页面，<strong>那是不是可以做到切换页面时也只通过 Ajax 获取数据更新页面，而不全部重新加载呢？</strong></p><p>答案当然是可以！如下图所示，用户第一次发起页面请求时，后端收到请求，然后取出数据库中的数据，返回 <code>CSS</code> 和 <code>JS</code>文件，<code>JS</code> 文件包括了页面切换逻辑的处理，这是单页应用实现的关键，它利用 Hash 或者 History 的技术，实现了当切换页面时，首先通过 Ajax 获取到新页面需要的数据，然后由 <code>JS</code> 根据要切换到的网址，使用获取到的数据来拼接出要展示页面的 <code>HTML</code>。整个切换页面的动作全部由前端来完成了。这就是单页应用，所有的资源只在第一次页面请求时被加载，后面都只会发起 Ajax 请求获取数据而已。</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823580/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/21_ozsza8.jpg" alt=""></p><h3 id="SSR-server-side-render"><a href="#SSR-server-side-render" class="headerlink" title="SSR (server side render)"></a>SSR (server side render)</h3><p>SPA 让 web 变成了应用的形态，它是客户端渲染（client side render）。客户端渲染有它的弊端，譬如没法做 SEO(Search Engine Optimization)，由于所有的 <code>JS</code> 和 <code>CSS</code>会在首次访问时被全部加载，并且 <code>HTML</code> 是在前端组装的，就势必导致首屏加载以及渲染的时间会增加，影响用户体验。</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823580/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/22_rawqx6.jpg" alt=""></p><p> 于是，现在又争先恐后的回到服务端渲染，想想真得挺可笑的，十年前为了搭上 Ajax 的班车纷纷做SPA，做客户端渲染，现在反而又想着法儿的要重新做服务端渲染。 </p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1578823581/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/23_onkm1p.jpg" alt=""></p><p>其实本质是一样的，所以这里其实是有历史包袱的，在项目开始之前，先想想清楚到底有没有必要做成 SPA 比较重要，而不是一味的趋之若鹜。</p><p>当然现在的服务端渲染和之前的服务端渲染在形式上还是有区别的：</p><p>之前的服务端渲染基本是围绕页面为中心的开发模式，只需要处理 模板-&gt; <code>html</code>字符串的转换，性能要优于现在的服务端渲染</p><p>现在的服务端渲染基本是围绕组件为中心的开发模式，开发效率和可维护性当然更高，组件也可以统一通过模块构建工具如webpack一并处理。</p><p>有一些 web 应用如果就应该使用 SPA 模式，但又想要 SEO 怎么解决呢？</p><p>当搜索引擎的网络爬虫过来的时候，其实是可以通过头信息判断的，于是有一种创新的解决方案，可以在中间层写个服务，对请求进行拦截，譬如 Rendora 就是解决这个问题的，之前写好的项目一句不用改，只需新起 Rendora 服务，对于爬虫的请求额外增加服务端渲染，返回生成好的 <code>html</code> 就好了，对于非爬虫，之前该怎么玩儿就怎么玩儿。</p><h3 id="Node-amp-全栈"><a href="#Node-amp-全栈" class="headerlink" title="Node &amp; 全栈"></a>Node &amp; 全栈</h3><p>2009年，Node 项目诞生，它是服务器上的 JavaScript 运行环境。Node的出现令前端开发拥有了控制服务器的能力：</p><p>Node = JavaScript + 操作系统 API</p><p>下一节聊聊 Node</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://link.zhihu.com/?target=https%3A//wangdoc.com/javascript/basic/history.html">JavaScript 语言的历史</a></p><p><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5b5adc9b6fb9a04f9244555d">大前端的技术原理和变迁史</a></p><p><a href="https://link.zhihu.com/?target=https%3A//logrocket.com/blog/history-of-frontend-frameworks/">History of front-end frameworks</a></p><p><a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/gNtpdMRL6JqNMr_tJsCVdA">WEB前端发展史</a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.linkresearcher.com/information/cb9aadac-a124-4708-b4f7-ecb4fd804bdb">万维网 WWW 的三十年</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">MVC，MVP 和 MVVM 的图示</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 前端发展史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker分层存储及存储驱动简介</title>
      <link href="/201912/dockerfencengcunchujicunchuqudongjianjie/"/>
      <url>/201912/dockerfencengcunchujicunchuqudongjianjie/</url>
      
        <content type="html"><![CDATA[<p>我最初是怎么接触到 Docker 的已经无法追溯，可能是大学期间闲来无事，不知道哪里看到了 Docker 的介绍，便在自己电脑上装了一个玩玩，在当时也没有意识到这项技术的应用性，感觉自己不怎么用得到，便再也没有进行更深入的理解。大三在腾讯实习时，导师是个容器大佬，做的也是容器相关的业务，而我早就把 Docker 的知识抛在脑后了。在这边我认识到容器是如何被用在生产环境中，通过 Kubernetes 来管理容器是多么的方便，自此对容器方面兴趣颇大。忙完秋招后，趁着这段比较闲的时间，我重新审视和学习容器这项技术，希望自己未来能在这方面有所建树。</p><h2 id="Docker-存储结构"><a href="#Docker-存储结构" class="headerlink" title="Docker 存储结构"></a>Docker 存储结构</h2><p>了解过 Docker 的人应该多多少少知道 Docker 是用一种分层的方式来存储镜像和容器，就像我在简历上不知廉耻地写上“了解 Docker”，被问到时只能支支吾吾回答一个“分层”。</p><blockquote><p>程序猿一到工位，所有的人便都看着他笑，有的叫道，“程序猿，你头顶又变秃了！”他不回答，对黑框框敲出，“ docker run -itd *** /bin/bash ”,便拍出一击 Enter。他们又故意的高声嚷道，“你一定不知道 Docker 的底层原理。”程序猿睁大眼睛说，“你怎么这样凭空污人清白……”“什么清白？我前天亲眼见你论坛上跟人争辩，还百度查。”程序猿便涨红了脸，额上的青筋条条绽出，争辩道，“百度的不能算不知道……借鉴！……敲代码的事，能不借鉴么？”接连便是难懂的话，什么“分层存储”，什么“只读可写”之类，引得众人都哄笑起来：公司内外充满了快活的空气。 </p></blockquote><h3 id="联合文件系统（UnionFS）"><a href="#联合文件系统（UnionFS）" class="headerlink" title="联合文件系统（UnionFS）"></a>联合文件系统（UnionFS）</h3><p>联合文件系统（UnionFS，Union File System）是一种分层、轻量级且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。虚拟文件系统（ VFS , Virtual File System ）可以简单理解为：包含所有层次中的所有文件，并展现给用户的一个文件系统。</p><p>如下图：</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1577027611/Docker%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8%E5%8F%8A%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B/6_pydxuh.png" alt="VFS"> </p><p>在这张图中，用户的增删改查操作只能在 VFS 上进行。实际上，左边的三层都可以进行权限定义，定义是否只读或可写，如果设为“只读”，那么在 VFS 上的操作不会影响到左边的文件，如果设置为“读写”，在操作 VFS 的同时，也会影响到原文件。默认情况下，最上层的是“读写”，其余均为“只读”。</p><p>UnionFS 是 Docker 镜像的基础，镜像可以通过分层来继承，基于基础镜像制作各种具体的应用镜像，不同的镜像可以共享一些基础的文件系统层，同时添加上自己独有的改动层，大大提高了存储效率。</p><p>Docker 18.03 中支持的联合文件系统可以在源代码中查到：</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1577007753/Docker%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8%E5%8F%8A%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B/1_s5oogw.png" alt=""> </p><p>暂不做这部分的详细讲解，之后我会对常用的存储驱动做一个详细的学习。</p><p>使用 docker info 命令可以看到当前 docker 使用的是什么存储驱动，我这个使用的是 overlay2</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1577009287/Docker%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8%E5%8F%8A%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B/2_s0vj6o.png" alt=""> </p><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p><strong>镜像</strong>是一系列<strong>只读层</strong>的统一视角，即通过统一文件系统将不同的层整合到一个虚拟文件系统中，在用户的角度，看到的是这个虚拟文件系统，从而隐藏了多层的存在。顾名思义，只读层不可以被修改。</p><p>暂时不要关心层（Layer）中的内容，只把一个层当作一个单位就好。</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1577024854/Docker%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8%E5%8F%8A%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B/3_oze8pq.png" alt="镜像"> </p><p>构建镜像时，前一层是后一层的基础，每一层构建完成后就不会再发生改变，<strong>后一层上的任何改变，都只发生在当前层</strong>。例如我删除某个文件，其实并不是真的删除了，只是在这一层标记该文件删除。运行容器时，虽然容器中看不到该文件，但该文件依然存在。所以在构建镜像时，应额外小心，每一层尽可能只包含该层需要的东西，任何额外的东西在该层构建结束前要清理掉。</p><p><strong>容器</strong>是在镜像上添加一层<strong>读写层</strong>，这样我们可以对这个虚拟文件系统进行读写操作。但要注意的是，<strong>读写层的生命周期与容器的生命周期一致</strong>，容器被删除后，读写层也随之消亡，任何保存在读写层的数据都将丢失。因此，容器不应该向读写层写入任何数据，所有文件写入操作，都应该使用数据卷（volume）或绑定宿主机目录。在启动容器时可以通过 –mount 或 -v 来进行操作。</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1577024854/Docker%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8%E5%8F%8A%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B/4_nd3c5k.png" alt="容器"> </p><p>镜像和容器的关系，用面向对象的思想来类比，可以看作类与对象的关系。不算静态成员的情况下，在对象中做出的修改（读写层修改）不能被反映到类中（镜像），但 Docker 中有方法可以将读写层的修改保存，即 docker commit 命令。</p><p>commit 后的镜像继承了原镜像的层级，把容器的读写层转化为只读层，比运行容器的基础镜像多了一层，用面向对象的话来说，commit 后产生的镜像，是原镜像的“子类”，继承了原镜像的特性并添加了自己独有的其他特性。</p><p><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1577024855/Docker%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8%E5%8F%8A%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B/5_oafumm.png" alt="commit"> </p><p>但要尽量避免使用 commit ，之前提过，<strong>后一层上的任何改变，都只发生在当前层</strong>。如果长期使用 commit 制作镜像及后期增删改查，在虚拟文件系统上看起来整洁许多，但实际上之前的文件都存在，会使得镜像越来越臃肿。除此之外，使用了 commit 制作镜像，除了当事人以外，别人无从得知执行过什么命令，即使是当事人也难免会遗忘一些操作。所以制作镜像推荐使用 Dockerfile。</p><blockquote><p><strong>注意：根据 VFS 那张图，读写层实际上不是用户所面对的文件系统，在读写层进行的操作，其实是在虚拟文件系统进行的操作，但对虚拟文件系统的操作会被映射到读写层上。所以不抬杠地讲，我们操作了读写层。</strong></p></blockquote><p>Dockerfile 部分也暂不详细说明，但要强调一些与我们讨论的存储结构有关的东西。Dockerfile 中每一个 RUN 命令都是一次 commit ，一个 RUN 命令执行时，首先先以当前镜像状态启动一个容器，在容器上进行读写操作，然后 commit ，退出并删除容器，再进入下一步构建操作。即一个 Dockerfile 文件中有多个 RUN 操作时，Docker 在不停地执行”运行容器”- &gt;”执行命令”- &gt;”commit”- &gt;”退出并删除容器”这样的操作。而上面我们提到，过多的层次会导致镜像的臃肿，所以要尽可能地控制 RUN 的次数，在一次 RUN 操作中，完成所有需要完成的工作，而且在最后要删除一些无关依赖，否则这些依赖将永远地留在这一层，使镜像变地更加臃肿。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>后一层上的任何改变，都只发生在当前层；</li><li>读写层的生命周期与容器的生命周期一致；</li><li>docker commit 命令可以将容器读写层转化为只读层添加在基础镜像上，成为一个新的镜像；</li><li>基于第 1 条，在读写层进行删除操作，不会使镜像或容器体积减少；</li><li>基于第 2 条，进行数据存储需使用 volume 或挂载宿主机；</li><li>基于第 1、3、4 条，commit 命令有导致镜像臃肿的风险；</li><li>RUN 命令是一次 commit 操作</li><li>基于第 1、6、7 条，应尽量在一次 RUN 中完成当前层次的全部操作，最后要记得删除无关依赖；</li><li><strong>补充：</strong>读写层实际上不是用户所面对的文件系统，在读写层进行的操作，其实是在虚拟文件系统进行的操作，但对虚拟文件系统的操作会被映射到读写层上。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 存储驱动 </tag>
            
            <tag> UnionFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins job间触发</title>
      <link href="/201912/jenkinsjobtrigger/"/>
      <url>/201912/jenkinsjobtrigger/</url>
      
        <content type="html"><![CDATA[<p>​        最近在实习,工作内容多多少少跟 Jenkins 有点关系,一段时间的学习下来,对 Jenkins 也有了一定的了解.<br>​        就我个人愚见, Jenkins 的用法远比其官方文档所描述的多的多,文档事例仅针对 Jenkins pipeline 举例,对 Github , Gitlab 等代码管理平台上仓库的代码进行管道化的定义,以满足其编译,部署,测试等方面的需求.在我所在的小组维护的 Jenkins 集群中,我了解到了更多的用法. Jenkins 集群可以用于机器管理;一个 Job 可以使用 shell 、python 等脚本语言进行定义,可以实现如 代码编译、代码测试、应用后台管理、微服务部署、集群管理等,甚至可以模仿微服务架构,将一个频繁使用的功能创建多个 Job ,对这些 Job 实现类似”负载均衡”效果.<br>​        昨天我导师给我一个需求:简单来说就是要两个 Job 之间带参数触发(实际上还要复杂的多).在经过一段时间了解和学习,现总结一下 Jenkins job 之间实现触发的方式.</p><h4 id="Parameterized-Trigger-Plugin"><a href="#Parameterized-Trigger-Plugin" class="headerlink" title="Parameterized Trigger Plugin"></a>Parameterized Trigger Plugin</h4><p>在 Jenkins 插件管理中添加 Parameterized Trigger Plugin,这个过程不累述.这个插件可以根据已经完成构建的结果,触发新 Job 或者传递参数.  </p><ol><li>创建两个 Job (名字不重要):<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853219/jenkinsjobtrigger/1_krigtv.png" alt="Job截图"></li><li>来看看 odm-job 的配置<br>在”Add build step”中选择”Execute shell”,我写了一段简单的 shell 来代表此 Job 所做的一系列操作.<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853220/jenkinsjobtrigger/2_xkt8jz.png" alt="odm-job"></li><li>Build 模块下应该会有一个”Post-build Actions”模块,顾名思义,就是在此次 build 结束后触发的操作.我们在”Add post-build action”中选择”Trigger parameterized build on other projects”选项,其他选项都是各自不同的行为,有兴趣的可以自己试一试.<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853220/jenkinsjobtrigger/3_deylfw.png" alt="添加Post-build Actions"></li><li>添加后,按照提示填写”Projects to build”,即需要触发的 Job 名称.勾选”Trigger build without parameters”.<br>在不传递参数的情况下如不勾选此项,将无法触发 Downstream :<pre><code>[parameterized-trigger] Downstream builds will not be triggered as no parameter is set.</code></pre><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853220/jenkinsjobtrigger/4_hbqtbj.png" alt="填写post-build Actions信息"><br>顺便提一下,这里的 Downstream 即 sign-job ,相对的还有 Upstream ,就是指 odm-job .</li><li>sign-job 的配置很简单, Build 中写一段简单的脚本来代表其构建的过程<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853220/jenkinsjobtrigger/5_ltaskm.png" alt="sign-job build">  </li></ol><p>保存,构建 odm-job 看看:(我是在 Jenkins 集群上运行的,打码部分为服务器及 workspace 信息)<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853220/jenkinsjobtrigger/6_rti30x.png" alt="运行结果"><br>sign-job 的运行结果:<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853221/jenkinsjobtrigger/7_o8cgg2.png" alt="运行结果">  </p><p>如果要传递参数,我们来做一些简单的修改:  </p><ol><li>odm-job 添加两个参数:<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853221/jenkinsjobtrigger/8_wmmcwz.png" alt="添加参数">  </li><li>sign-job 添加两个参数及构建脚本:<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853220/jenkinsjobtrigger/9_ug7cow.png" alt="添加参数"><br>修改脚本:<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853220/jenkinsjobtrigger/10_ohzvwv.png" alt="修改脚本">  </li><li>修改 odm-job 配置:<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853221/jenkinsjobtrigger/11_tzogjv.png" alt="修改配置">  </li></ol><p>再次构建 odm-job 看看结果(记得传参数,我给的参数是 ODM_PATH=111;ODM_TEST=222).odm-job 并没什么不同,主要看看 sign-job 中是否接收到传递过来的参数:<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853221/jenkinsjobtrigger/12_y9ipra.png" alt="结果"><br>可以看到参数已经传过来了.上述就是使用”Post-build Actions”触发 Job 构建的过程.</p><h4 id="Conditional-BuildStep-Plugin"><a href="#Conditional-BuildStep-Plugin" class="headerlink" title="Conditional BuildStep Plugin"></a>Conditional BuildStep Plugin</h4><p>直译过来就是”有条件的构建步骤”</p><ol><li>删除 odm-job 中的 Post-build Actions ,在 Build 模块中添加一个”Conditional step”,有 single 和 multiple 两种模式,这里我用 single .<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853222/jenkinsjobtrigger/13_unozzu.png" alt="添加 Conditional step">  </li><li>“Conditional step”可以分为两部分,下半部分与之前 Post-build Actions 没太大差别,上半部分就是所谓的”条件”.条件我一般使用 Execute Shell ,在下面的脚本中, exit 0 为触发构建, 除 0 外的 exit 都将不触发构建.除此之外,还有很多其他条件可供选择,有兴趣可以一一试验.<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853221/jenkinsjobtrigger/14_zlminv.png" alt="Conditional step"><br>这里的条件是如果参数都不为空,则触发构建.  </li></ol><p>先用参数构建 odm-job 看看:<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853222/jenkinsjobtrigger/15_hutjs5.png" alt="参数构建"><br>可以看到触发了 sign-job 参数也成功传递过来了,<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853222/jenkinsjobtrigger/16_zvkcho.png" alt="触发"><br>再使用空参数构建 odm-job 看看:<br>看得出 sign-job 并没有被触发<br><img src="https://res.cloudinary.com/dkzvjuptx/image/upload/v1576853222/jenkinsjobtrigger/17_lbjgon.png" alt="空参数构建"> </p><h4 id="两种方式的不同及使用场景"><a href="#两种方式的不同及使用场景" class="headerlink" title="两种方式的不同及使用场景"></a>两种方式的不同及使用场景</h4><p><strong>不同:</strong> Post-build Actions 不能使用条件选择,只要被添加在后面,就一定会被触发; Conditional step 可以使用条件选择,满足一定的条件才可以被触发.<br><strong>使用场景:</strong> Post-build Actions 适合用在前者构建结束后必触发后者的场景; Conditional step 用于基于前者的构建情况,有选择性地构建后者,甚至可以设置有多个 Conditional step ,根据不同的情况选择构建不同功能的 Job ,类似编程语言中的条件语句,或者说类似设计模式中的策略模式(但没有满足开闭原则)</p>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
            <tag> job触发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永不消逝的电波</title>
      <link href="/201912/yongbuxiaoshidedianbo/"/>
      <url>/201912/yongbuxiaoshidedianbo/</url>
      
        <content type="html"><![CDATA[<p>　　看科幻是我的兴趣之一，我看过几乎所有评价高的科幻电影或小说。这篇《永不消逝的电波》是我看过最让我动之以情的小说，一次又一次让我哽咽。小说是以宇宙中一个高等文明拉修姆人的个体的角度，在宇宙中飘荡的电波中，捕捉到一个低级文明（地球文明 ） 为了文明的延续，敢于和宇宙开玩笑的努力和挣扎。特殊的是，文中所有关于地球文明的信息，都是通过飞船间通讯的只言片语中拼凑出来的。</p><p>　　拉修姆人是在一次迫降中来到拉修姆星，他们忘记了自己的来历，丢失了原有的科技，却通过收听宇宙中其他文明的电波，慢慢把文明重新拼凑起来，重返银河舞台。在故事的最后，主人公惊奇地发现自己倾听这么久的电波，正是当初走出地球，迫降到拉修姆星上的那批先锋者！“忘记就是背叛，达.伽马号！”，他们也不想忘记，但为了延续文明，他们不得不忘记；“ 他们退回洞穴，我们步入星海 ”，在面对大部分人宁愿呆在资源匮乏的星系中慢慢消亡的时候，达.伽马号和殖民二号毅然孤独地向深空中驶去。作者用最短的篇幅，最简单的角度，写出了科幻小说中最为悲壮的史诗感。</p><p>下面为原文：</p><h4 id="永不消逝的电波"><a href="#永不消逝的电波" class="headerlink" title="永不消逝的电波"></a>永不消逝的电波</h4><p> 作者：拉拉</p><p>　　时间是——标准时间+1000亿秒。<br>　　“开拓者……兹……在你的前方……兹……确认……”<br>　　“……兹……建议改变轨道……它看起来很不稳定……兹……”<br>　　“改变航向，77-1045-37-……兹……”<br>　　环境音效发生器一声无奈的哀鸣，关闭了。空间骤然陷入一片黑暗，连接插头里的能量也如同退潮的海水般消失得无影无踪。应急灯立刻亮了起来，将房间投入惨绿的昏暗光影中。<br>　　尼古拉徒劳地伸手在面前划拉几下。没有任何反应，看来这次是把“下流胚子吧”的总保险给烧毁了。<br>　　过了几秒，“嗡”的一声轻响，能量又偷偷溜回房间里，房间里响起一阵“窸窸窣窣”的声音，那是时空正在偷偷地溜回现实空间。尼古拉叹了口气，身体微微一挺。接驳在两肩的灵敏型调节机械臂同时松开，微微喷着润滑气体，缩回墙里。他光溜溜地站起，左手和右手从储物柜里飘出来，接上他的肩膀。<br>　　尼古拉咳嗽一声，那声音立刻在四面八方响了起来，吓了他一跳。他的语音系统还接驳在小房间的公共频道上，忘了收回来。<br>　　看来在这个以千万秒为刻度的时空泡上，已经很难再深入地追查了——而且恐怕某人也绝不会让他追查下去了。<br>　　他悻悻地走出娱乐室，卡格看见了他。他的身体正在娱乐中心的另一面处理故障，于是他在尼古拉面前打开了一个浮空窗体，气急败坏地跟着尼古拉往外走。<br>　　“嘿！我说你！见你的鬼去吧，小兔崽子！”卡格热情地向他打招呼。娱乐中心的贩子通常都恨不得顾客一直烂在某个角落里，只要一直往账上打钱就行。尼古拉是卡格唯一的例外。他在30万秒前就宣称，如果“下流胚子吧”再次能量过载，他就要把尼古拉倒着扔出去。看来是实践他诺言的时候了。<br>　　“好吧，”尼古拉边走边说，“我走。”<br>　　“你就不该来！瞧你干的好事——你一个人用了6万氪能量！我真不知道你是怎么干的？用嘴嘬吗？”<br>　　“我用了一下时空泡而已——那不是你们的设备吗？”<br>　　“我们不用那玩意儿！那是用来糊弄电检处的！”<br>　　“我上别家去。”尼古拉说着，一面快速地穿过“下流胚子吧”的狭窄小巷子，他的身体的其他部件奋力赶上他，回到各自的位置。他的听觉系统最后一个回到脑袋上，这时候，他听见卡格在后面喊：“那你干吗不去‘老实水手吧’？他们有100套时空泡，最小刻度1千秒！足够你精确定位到你出娘胎的时候！”<br>　　尼古拉停了一下，花了几秒钟时间来考虑这个建议。老实说，他很感动。因为“老实水手吧”是本地另一家大型的娱乐中心，规模比卡格的“下流胚子吧”还要大，而且，毫无意外的，老板是卡格的死对头。卡格一时冲动说出这种话来，事后肯定会后悔很久，而且把自己的逻辑判断单元送到工厂去维修。<br>　　“好吧，我去。”<br>　　“愿主诅咒你！”卡格跟他告别。<br>　　凭良心说，“老实水手吧”的确比“下流胚子吧”高档得多，令人惊讶。走进前门大厅，你几乎能遇见城里的每一个人——当然得除去上“下流胚子吧”的人——人人都面带急色，匆匆地想要进入自己预定的世界中去快活。他们把自己的下肢、身体和推进器留在存物间里，塞得满满当当，那里面应有尽有，足够装配一艘空间飞船了。吧台的服务人员显然对这种状况感到满意，因为那代表他们的客户正在他们的刷卡机上源源不绝地透支。<br>　　尼古拉把后肢推进装置留在车库里，慢慢走向前台。前台服务员向他堆出一脸媚笑。<br>　　“尊敬的先生——”<br>　　“我要用一下你们这儿的时空泡。”尼古拉用他那少年沉闷的声音。<br>　　“哪一种型号？”服务员顿时笑花了眼。<br>　　“哪一种都行，”尼古拉说，“我只需要在一处完全干净、无打扰的空间，可以在以1千秒为单位的时空里来回，搜索空间背景信号就行。”<br>　　服务员的笑容僵持了几秒钟。<br>　　“嗯……您需要来一些打特价的特色服务吗？”<br>　　“不。”<br>　　“时空泡可不便宜，”服务员微酸地说，“如果不需要其他服务，我们可得有个保底价……”<br>　　“好的。”<br>　　服务员把一块牌子扔出来。“往里走，3775层，1190号。”他简单地说，省去了一切虚伪，“每100秒1000块，不包茶水。”<br>　　房间里一片黑暗，尼古拉花了好长时间才在黑暗中摸索到坐椅。用拉斯龙皮做的椅子又硬又凉，他躺上去，身体稍稍陷入沙发，感觉到一些东西慢慢爬进自己颈后的皮肤，一溜凉风吹入自己思维的深处。<br>　　他的意识和房间的控制平台接驳上了。尼古拉耐心地在平台上寻找开关。<br>　　突然亮起一丝光，就在离他不远的地方。那丝光线是一束从天花板拖到地面的笔直的光，慢慢变得宽阔起来，原来是落地窗前的窗帘拉开了。<br>　　屋子里亮堂起来，很快便达到了耀眼的程度。位于第3775层的房间已经超出了行星拉修姆稀薄的大气层外围，双子星普拉迪斯和拉格里奥同时无遮无蔽地出现在天际的右上方，把它们的万丈光芒投射进来。即使尼古拉的眼球外围生成了黑色保护膜，也花了很长时间才适应这可怕的光能辐射。<br>　　他站起身，走向窗前。拉修姆星黯淡的地弧线在身下很远的地方，只反射出微微的橙黄色光芒。除开双子恒星，天幕上实在看不到几颗星星，在银河的这个偏远角落，能看到的星海实在有限。在前方几毫光秒外，他能看见太空城Putian the 3rd孤寂的身影。更远的左下方，他甚至能看见壮观的Tasha尘埃云。它硕大无朋的身躯在距离联合星系不到2500光秒的远方旋转，正在形成新的行星，围绕在双子星系周围的星尘受它吸引，形成一道长达数千光秒的水幕，正源源不绝地倒入尘埃云的旋涡中。<br>　　这倒真是个好地方。尼古拉微微一笑。在整个星球上，也许再没有比这里更好的地方了。<br>　　他重新坐回椅子，将两只胳膊从肩上卸了下来，接上房间提供的时空泡控制手臂。这两只新的胳膊可不轻，而且和他的身体有些排斥，他花了好些工夫才打开所有控制窗口，依次开启时空泡的各项开关。<br>　　房间微微震动一下，脱离开大楼，向外空飘去，但并没有走多远，一种难以言喻的紫色光芒包围了它，然后将它融解——时空泡在引力导索的牵引下，缓缓滑入了时间的长廊中。<br>　　从表面上看，似乎一切如常，但若细心观察，遥远的Tasha尘埃云开始古怪地旋转起来，有时候顺着转，有时候逆着旋转。横过天际注入其中的水幕，也变得模糊起来，看起来几乎是同时流入并且倒着流出尘埃云。<br>　　这一切都取决于尼古拉的右手手指。当他轻轻拨弄时，时空泡就在大约3000亿秒①长的时间轨道上快速地来来回回，这是游戏街机能达到的最大尺度了。主要是能量问题，这房间惊人的费用一大半都花在可怕的能量消耗上。<br>　　他把时间定在约1000亿秒之后，然后投下重力锚，时空泡在扭曲空间的缝隙处微微摇摆着。他卸下控制手臂，将自己在无线电兴趣小组里组装的接收臂装上身体。来自宇宙背景深处的杂乱信号立刻充满了他的脑海。<br>　　耐心搜索——那个频段非常特殊，没用多久，便从一片噪声中浮现出来。<br>　　“达·伽马号……兹兹……这里是开拓者号……兹……我们距离……大约11000光秒——我们能看见通道，前导火箭开辟的道路非常清晰……星环在我们6-2方位大约3000光秒……”<br>　　“开拓者，请再次确认轨道。轨道平面有大约1.5%的偏移。”<br>　　“达·伽马，我们能看见。非常清楚。我们能穿过星环。”<br>　　“开拓者……开拓者……信……开拓者！刚才的通信中断是怎么回事？开拓者，请回答！”</p><p>　　“这里是达·伽马，开拓者，请回答！”<br>　　信号在这里中断了。尼古拉脸上露出得意的微笑。他成功地追上了那个信息源，看样子，在1000亿秒之后，“它们”还在路上。<br>　　现在该说说清楚了。实际上，尼古拉是一名“倾听者”组织的隐修会成员。<br>　　在“普拉迪斯—拉格里奥”联合星系，花样百出的组织多如繁星，但像“倾听者”这样的组织还是凤毛麟角，颇受人崇敬，因为这个组织一度是拉修姆繁荣进步的依靠。<br>　　拉修姆人并非是拉修姆星球上的原生动物——真正土生土长的拉修姆种族已经全部上了他们的菜单。大约1800亿秒之前，拉修姆人的祖先横渡浩瀚银河，从一个不为人知的地方来到联合星系，然后，与所有同类型的小说一样，飞船在登陆拉修姆时出了故障——如果硬要把穿越了数千亿光秒宇宙空间、早已破烂不堪的飞船一头扎进地里称为“登陆”的话。在那场登陆中，拉修姆人损失惨重，幸存者寥寥无几，几乎没能从大火肆虐的飞船中抢救出任何有用的东西。<br>　　拉修姆星位于银河外缘，与兴盛发达的银河文明遥遥相隔。行星受到两颗太阳的同时焦烤，对任何有机体而言都如同地狱般灼热。几百亿秒过去，已经失去一切能源供给的幸存者们不得不远离他们的飞船残骸，向稍微黑暗、凉爽一点的大陆深处流浪。没有了文明载体，幸存者们渐渐遗失了过往的一切，文化、语言、技术……甚至是前来拉修姆星球的经历。他们在拉修姆上过了好几百年跟土著动物争吃对方的日子，如果这种日子持续下去，幸存者很快就只能从石器时代开始重头再来了。<br>　　所幸的是，幸存者保留下来的为数不多的古老技术中，包括了“深空电磁波接收”这关键的一项。“普拉迪斯—拉格里奥”联合星系远离银河文明的核心区域，在重新恢复技术文明、联结到文明网络之前，幸存者中的许多人长时间倾听深空。他们接收、破译混杂在宇宙微波辐射中那些来自银河各个角落、长达数亿年都不会消散的电波，这些电波带来知识和文明，帮助落难的拉修姆人重新拼凑起文明。<br>　　200亿秒前，拉修姆人终于成功地重返银河文明圈，从那时开始，银河文明网成为联结这个世界与整个宇宙的桥梁，而倾听则变成了一种怀旧，一种高尚的情趣，一种无聊的打发时间的方法。这个组织的成员都是些修士——至少人们都是这么认为的。“倾听者”倾听宇宙中的一切声音，他们日复一日地改进他们的接收装置，分成许多流派，这些流派通常试图听清楚以下内容：<br>　　银河的呻吟声；大天鹅座钟鸣般的脆响；β-4星系连绵不断的滴答声；“孤行者”行星划过天际时的嗖嗖声；牛头座星云里尘埃们的窃窃私语；巴·卡迁星系里那个奇怪种族不停的擂鼓声——他们不知疲倦地敲啊敲啊敲，以至于文明都中断了，最近3000万秒再也听不到任何动静；最激动人心的是倾听克里克斯星云水河注入Tasha的轰鸣——这声音简直大得像宇宙爆发之初的巨响，喜欢这个调调的人都是苦修会成员，每过两个月就要更换他们的听觉系统，有的甚至还需要做心理辅导。<br>　　倾听给拉修姆人带来知识和财富，引领他们步入新的世界，给拉修姆人带来无穷的乐趣，但有一件事情被人们遗忘了——拉修姆倾听者从来没有听到过自己母星的声音。在漫长的星际旅行中，他们已经忘了自己是谁，来自何方，在从前发生过什么。他们开始称自己为拉修姆人，好像他们真的在这里出生、长大一样。<br>　　尼古拉，像我们前面说过的那样，是一名隐修会成员，这个会是所有倾听者组织中最保守、最传统的一个，虽然尼古拉看起来像个没管教好的小屁孩，穿得令他老妈难以忍受，成天出没于娱乐场所，吸食迷丶幻药。然而命运是如此会捉弄人，大学时代，在一个歇斯底里的派对上，他吸食了过量迷丶幻药，神魂颠倒地把自己关在实验室里，结果，制造出一种全新的无线电接收装置。<br>　　这是一台“倾听过去”的装置。它只能接收600兆赫以下的“原始”频段电磁波段，在这个波段内，电磁波老老实实地在第一速度的限制下穿越空间②。银河文明网络是不使用这种频率的，而如果偏远地区某个尚未进化的种族使用这个频率，它也需要好几千亿秒才能在银河系中跨越一小段距离，运气顶了天，被一台类似的装置接收到。拉修姆人依靠吸收先进文明才从泥坑中挣扎出来，谁还会有心思去管那些说不定早就灭亡了的文明留下的只言片语？因此，这个频率接收项目——用一句大学里很流行的话来说——很偏。没有人研究这个。尼古拉有幸成为当代唯一一个研究此项目的人，可以获得大笔经费，足够他逍遥快活地过一辈子。<br>　　尼古拉从人生的第一个叛逆期开始就喜欢上了“向后看”。他喜欢研究历史，倒霉的是，拉修姆人没历史，也没有自己的文化和传统，连一家博物馆都没有。要想研究历史，你就得登录银河网。用Gooooooooooole搜索“历史文化”这个词，可以产生1万亿个网页。可如果你搜“拉修姆的历史”，还不到1000个，其中800个都是介绍拉修姆独特的饮食文化。<br>　　这台疯狂的机器一定是从他的潜意识里爬出来的——它就提供历史，其他什么作用也没有。这东西能够从无止境的宇宙背景噪声中，捕捉到那些细微的原始信号，每一段信号都代表着一段被遗忘了的历史：那些也许永远消逝了的种族和文明，在消亡很多很多年之后，只有这些静电噪音在默默地诉说涅灭在历史中的爱恨故事。尼古拉把它们一一记录在案。谁知道在这里面是不是隐藏了关于拉修姆人前生的秘密？<br>　　他是在200000秒（拉修姆星的现实时间，而非尼古拉在时空泡中经历的时间跨度）前发现这个奇怪频段的。这是一段包含了原始音视频的信号，它跨越了银河浩瀚的空间、前后数千亿秒，已经在寒冷的宇宙空间中损耗了绝大部分能量，接收到它们实属撞大运。<br>　　起初，尼古拉并没有太在意这段信息。这种东西太普遍了，充满整个银河，好像所有的种族都迫不及待地向外高调宣扬自己存在似的。然而，听取几遍之后，他赫然发现，这是一段带有明显拉丁语系特点的信息。<br>　　在银河文明网上，联结了数以亿计的文明圈，所有的文明都通过两种语系进行交流：拉挈魏语系，这个语系由34564个表意和47125个表音的词汇组成，十分复杂，但是因为这复杂的语言体系能够描述银河中的大部分丑恶现象，因此为各文明圈通用。恰克恰克语系，这个语系由一连串——没错，就是一连串，没人数得清到底有多少个——类似于“恩”“呜”“呃”“啊”之类的元音组成，而实际上这些词毫无意义。交流者本身是通过这些语气词传递精神语言，在双方的脑海中形成真正的语义。这个语系流行于靠近银河中央星群的一些智商高度发达的种族中，他们才不屑于与开口说话的种族交流呢。<br>　　而拉修姆人的母语则属于拉丁语系，也就是字母少于60个的语言系统。在黑暗时代里，他们几乎把母语忘了个精光。联上文明圈之后，拉修姆人全面倒向了拉挈魏语系，原因很简单，拉丁语系由不到60个表音的字母组成，由此产生的语义实在单调，在银河这个大圈子里，连骂人都不够。只有靠近银河边境的少数未开化种族还在使用这种语言，这可使他们少浪费时间在口沫横飞地说话上；再说了，在那些以光速为最高时速的世界里，传递复杂的语言纯粹是跟自己找没趣。<br>　　尼古拉研究过拉丁语系，这是他的嗜好之一，帮助他在倾听“过去”时，能够比较快地理解那些被监听到的只言片语。他听过的那些落后种族的语言，有时候真能把人烦死，哪怕是经过语言机器的再三净化，也摆脱不了里面混杂的各式俚语、脏话和问候人祖宗十八代的套话。这几乎成了进化上的一景。似乎在跨进文明圈的大门之前，低等种族都被限制了语言发展的上限，他们只能祈求上帝，能让他们用那贫瘠的语言把思想表达得更准确一些。<br>　　以下是尼古拉收到的这个频率的第一个信息段：<br>　　“远行者6号……兹……这里是莆田港……深空激光导航信号已经发射。”<br>　　“明白。信号清晰。远行者号请求离港。”<br>　　“远行者6号，港口已经打开，100秒后离港。”<br>　　“远行者6号明白。常规发动机开始点火倒数！”<br>　　“兹……兹……”<br>　　“远行者6号……1100秒后启动增压发动机……兹……”<br>　　“莆田港……兹……我们上路了……我们上路了！”<br>　　“祝你们顺利，远行者6号……你们将在600秒后切过黄道面……2000秒后，太阳风帆将完全展开，展开宽度5000千米，角度37度，接受太阳辐射70毫焦……太阳风将吹动你们，提供给你们穿越宇宙的动力……60000秒后，你们将进入沉睡，太阳在你们身后遥望，在此之前，请确保船内所有设备正常……兹……我们无法确知你们复苏的时间……30亿秒后，你们的速度将达到光速的五分之四……兹……失去太阳风的吹拂之前，航行电脑将会寻找到新的动力……目标是……孟菲斯大裂谷……你们……兹……将在500年后离开我们所处的旋臂，到那时，你们将不再有天，有年……秒将是你们穿越茫茫星海的唯一度量……故乡在你们身后，然而直到世界的末日，你们都无法再返回……兹……远行者6号，永别了。”<br>　　“永别了……泥土（原文为EARTH，故尼古拉的翻译系统翻译为泥土）。”<br>　　相对来说，这段信息所包含的有效数据并不太多。综合其后陆续收集到的信息，尼古拉花了很大精力，才从这些口齿不清、含混不明的发音中分离出5个元音和21个辅音，一共24个基础字母。他的翻译机指出，这些字母大约能组成全部共约20万个有效词汇——纯粹得不能再纯粹的拉丁语言。追本溯源，这段信息来自银河чш-4700旋臂的外沿部分，距离拉修姆星大约3000亿~3700亿光秒的距离。也就是说，这段信息的发送者，至少在3000亿光秒前，还存在着。<br>　　“远行者6号”似乎是这个种族第一次向数千亿光秒之外移民的先驱，它花了很长很长的时间才穿越它们的小星系，奋力进入一个孤寂冷漠、无边无际的空旷宇宙中。根据尼古拉后来的推测，它们走了一条极端危险的路：离开银河旋臂，直接穿越空间，去到另一条旋臂。这条路比从银河内部绕圈要近得多，问题是，对于初涉银河的人来说，这就好像离开江河，去到无边的海洋深处一样危险<br>这个种族距离进入银河文明还有长远的路要走，从语言上就看得出来。它们的语言甚至不能直译“多层面对流凯拉迪斯引力逻辑环”这样的术语，非得说一句土得掉渣的“时空隧道”来形容。这种语系是如此古老，甚至需要在词组组成的表意句式中，加入“时间语法”作为辅助。尼古拉一共分离出来11种时间语法，但他估计至少会用到15种以上。<br>　　穿越宇宙的无线电信息，具有中大奖般的素质：它们需要穿越浩瀚的星海，穿越看不见的电磁场、重力陷阱、高辐射中子星……那微弱的能量在数千年后还能被接收到，本身就是一个奇迹。没过多久，不管尼古拉在他的设备上下多大工夫，在那个时间段上再也找不到任何一丁点信息。<br>　　只能去时间里搜索幸存的信息了。尼古拉在时间轴上向后走了大约30亿秒，很快便找到了下一段信息。<br>　　?“远行者6号……兹……信号受到干扰……我们不清楚你们能否收到这信号……我们很遗憾地通知你们，太阳风已经提前停止……兹……太阳已经死亡……我们不知道发生了什么……海王星外轨道发生了奇异的变化……冥王星已经……远行者6号，已经向你们发送唤醒信号……等你们苏醒后，你们可以选择第二目标……远行者6号……兹……”<br>　　信息在这里终止了。<br>　　仅仅1亿秒之后，情况似乎变得十分紧急，发布人的声音穿越空洞无助的时空，仍然显得紧促焦急——至少，尼古拉的情绪翻译系统是这么认为的——这段信息十分微弱，似乎发射它的设备已经缺乏必要的能源补充。<br>　　“远行者6号……远行者9号……先进舰队……深空探测者7号……离岸舰队……你们在哪里……兹……我们无法定位……时间很紧迫……奥尔特云可能已经消失……空间扭曲得很厉害，我们已经无法观测……有什么东西向星系（一个特定称呼，翻译机认为这是以他们恒星命名的）扑过来了！有人吗？我们向你们呼唤……你们去到哪里……请你们尽一切可能传回星图……我们无法离开，无法离开！大灾难已经……兹……如果文明中断，谁来恢复……我请求你们……”<br>　　这段令人毛骨悚然的信息后半段永远消失在浩渺时空中。尼古拉在时间线上来回搜索，再也没有从银河那条旋臂传来的任何消息。那个文明已经在第一次出现的地方凋零，而一直到它临近终结时，它曾经发射进深空的那些舰队没有一支返回，或者传回星图。<br>　　也许曾经努力过……<br>　　也许根本没有时间返回……<br>　　也许那些舰队早就将它们的母星遗忘……<br>　　他打电话给银河那一头的朋友，问他那个旋臂小星系发生了什么事。“什么事？一颗超新星爆发了，把一颗中子星像乒乓球那样打了两万特拉斯③远……发生了什么事？一颗中子星还能干什么？想也想得到，它吞噬了沿途的所有东西，后来再度爆发，变成了一颗新星……问这个干吗？”<br>　　“问问呗……”<br>　　“问问？”<br>　　“……有一个小种族——”<br>　　“你是说，那中子星还干掉了一个小马蜂窝？”朋友在电话那头放肆地大笑起来。<br>　　“好吧，再见，特纳。”<br>　　“好。请我吃饭。再见。”<br>　　对大天鹅座β的特纳来说，也许一个边远地区未开化种族还当不了院子里的马蜂窝。特纳属于亚拉罕人种，这个有着巨大身躯、长着令人难以忍受的齿状腭的种族向来以吃掉那些弱小种族为乐。但尼古拉做不到。这段信息在他的心灵深处引起了不小的震颤，让他不由得想起拉修姆人从前那个已经消失了的、也许是被某个强大种族吃掉了的母星。他迫切地想要知道这个种族剩下的那些前往深空的人们的命运。<br>　　他将接收装置对准银河黄道面，来回搜索，搜索范围从100亿秒扩大到1000亿秒范围。对于那些还没有进化完成的种族来说，这已算是一段漫长岁月。终于，400亿秒后，接收装置再次在那个特定的频率上收到了一小段断断续续的信息。<br>　　“莆田2号……这里是搬运者77号……请求入港。”<br>　　“77号，你的承重比太低。”<br>　　“是的。小行星安姆已经干涸，再也找不到矿源……我们需要补充能源，前往下一个……但愿我们能……”<br>　　“愿主保佑我们，77号……”<br>　　重新找到的信号表明，那个种族已经在太空中生活了很长的时间，甚至可能远远超出它们生命的长度。它们离通过多维度自由来往于银河的技术还远得很，只可能是通过某种冷冻技术来延长生命。据传说，拉修姆人在抵达这颗行星前，也是使用类似的技术，以至于在坠毁时，还有大部分人没有醒过来——“死了个痛快”——传说用这句话结尾。<br>　　到目前为止，那个原始种族似乎只有当初的远行者6号上的乘员成功地存活下来。大灾难到来前，它们留在“泥土”上的母星文明也许曾绝望而狂乱地向空间发射了更多的飞船……可惜那些飞船要么没有躲过灾难，要么没有留下文明的种子，再也没有在银河系中留下只言片语。而其他提前飞离的飞船，比如远行者9号、先进舰队、深空探测者7号——尼古拉祈祷它们没有遇上特纳一族——也再没有任何回音。远行者6号幸运地在距离原旋臂最近的一支旋臂的边缘——很遗憾，离银河的核心区域更远了——的一个非常小的星系里定居下来，那是在2000亿秒之前的事了。<br>　　几百亿秒的时间里，它们小心地维护自己的文明，以小行星“暗星”为基地，不断地探索周围空间。但是，情况一天天变得糟糕起来。<br>　　“面向公众开放的……兹……反应堆将在2000千秒后停止……”<br>　　“……殖民院对此表示遗憾……”<br>　　“兹……殖民院……第七殖民卫星能量供应已经到达极限……请求立刻……”<br>　　“殖民院驳回请求……兹……已经没有足够的资源用于供给新的外空探索……”<br>　　“殖民院……矿石工厂将要关闭……”<br>　　“我们没有适合的人选……”<br>　　“……公务会要求减少前往空间工厂的……”<br>　　“……我们没有足够的原料继续供应空间项目……殖民院，我们要求削减空间项目……”<br>　　小星系里只有一颗昏暗的恒星和两颗足够居住的行星，而殖民者们的能量只能够维持他们不长的时间。这个星系里没有足够的资源，是一个典型的“无支持力”星系。听上去，它们似乎只来得及制造一个空间港口“莆田2号”，还不足以发展到星际旅行，资源就已接近耗尽。远行者6号的后代面临命运的考验，运气好的话，它们将永远停留在自给自足的未开发社会，运气不好的话……<br>　　尼古拉静静地等待着它们消亡。<br>　　几亿秒后，似乎已经到了决定命运的时刻。收到的消息，有的清晰，有的混乱。小世界正在前进与后退的巨大力量下分裂。<br>　　“达·伽马号，殖民院已经下令……兹……做好立刻离港的准备。”<br>　　“莆田2号……我们正在尽力发动……”<br>　　“你们要立刻……兹……接管港口内一切船舶的补给……”<br>　　“明白……”<br>　　“发射前准备，进入2000秒倒计时。”<br>　　“莆田2号！这点时间根本不够你们抵达舰上……兹……我们必须等待……”<br>　　“来不及了……兹……殖民院已经下令……远行舰队的成员来不及全部抵达港口……在这之前，我们就必须发射殖民2号……兹……你们只剩下这个发射窗口……兹……”<br>　　“达·伽马号明白。已做好发射准备……”<br>　　发生大事了。尼古拉提起精神，没有再驱动时空泡快速向前。他静静地等待着——信号中断了2800秒，然后，再次收到消息。<br>　　“达·伽马号……你的速度已达到10万千米每秒……你的目标星图已经上传到主处理器……兹……”<br>　　“明白。莆田2号，我们取道大裂谷，航向6-71-51，向SIPULITION星系前进。22000秒后，转入光速飞行。”<br>　　“达·伽马号，你们确信要穿越大裂谷吗？星图不太精确……兹……那段距离可能超出预期……兹……”<br>　　“莆田2号……我们没有选择……兹……没有足够的时间和燃料……我们只能冒险一试，否则……在我们穿越大裂谷后，将向第六纬度发射超视距定位信号。你们要紧跟我们……兹……”<br>　　“……兹……我们已经中断了与地面的一切联系……能量与物资供应已经中断……”<br>　　“他们退回洞穴，我们步入星海。”<br>　　“是的，达·伽马号……我们指望你们能……5000秒后，我们将登上殖民2号……兹……我们将在轨道上等待……我们将沉睡，直到你们将我们唤醒……达·伽马号，你们将独自面对3万光年的茫茫星海。祝你们顺利。愿主保佑我们大家。再见。”<br>　　“再见了……暗星……再见……人类。”<br>　　陷入了阶段式的无线电静默中。在其后的数百亿秒中，这个频段的背景辐射一直存在。达·伽马号孤独地向深空漂流，再一次效仿它的前辈远行者6号，穿越旋臂之间的空隙。在离开暗星所处的旋臂之前，达·伽马号偶尔会释放出它携带的行星系探测船“开拓者号”，探索沿途靠近的一些灰暗星球，但却总是失望。由于不可动摇的资源分配法则（这个法则在银河于远古自旋生成时就决定了），在远离核心的银河外缘，既是星系灭亡的坟场，同时也是能量与物质涅灭的墓地。这里没有可供给的地方。这里的灰寒星群每分每秒都在向经过者发出亡灵的啧啧声，警告它们离开荒漠，回核心去。200亿秒后，达·伽马号进入绝对空旷的宇宙空间，不得不停止了此类活动，进入了长期睡眠中。<br>停留在暗星轨道上的莆田2号港口很快就被放弃了，在最后时刻，甚至有一部分港口的守卫被迫与港口同归于尽，才保证另一部分人顺利地登上殖民2号。但殖民2号飞船没有立刻离开小星系。在暗星的一个较远的轨道上，殖民2号的人们满怀希望与恐惧入睡，期待着有被唤醒的一天。<br>　　那些留在暗星上的人类再也没有把他们的视线转向深空。<br>　　由于达·伽马号具有超越原始电磁波的速度，它将在宇宙中把它自己的信息甩在身后很远，所以，尼古拉不得不把时间一段一段向后推。需要同时计算空间与时间的关系，才能牢牢地抓住那道一闪即逝的电波。<br>　　770亿秒后，突然，某一天，达·伽马号的船员醒了过来，而且是在十分紧急的情况下。不知出于什么原因，船员们打开了公共广播系统，似乎是想将此时此刻的信息直接透露出去，让其他未知的接收者听到。<br>　　“……从现在的时间计算，我们已经偏离轨道2万……不，3万2千光秒……”<br>　　“不可能……重新校验的陀螺仪一切正常……在过去的770亿秒中，陀螺仪一直稳稳地对准……兹……”<br>　　一阵嘈杂的声音。<br>　　“这是航行电脑在过去的200亿秒内绘制的新星图——这是我们在暗星上预测的航行星图……两者的差距已经扩大到……”<br>　　“……我要提醒你……我们的目标，是牢牢对准红巨星——现在它就在你我的面前。”<br>　　一阵可怕的沉默。<br>　　从过往收集的资料上，尼古拉估计达·伽马号上有200到250名船员，但做主的大约只有3到6人。其中一人被其他人称为“船长”，还有一人被称为“航行长”。巧合的是，“航行长”这个名字的发音与拉修姆星“总督”的发音十分相近。<br>　　上面发言的就是“船长”和“航行长”。航行长发现飞船偏离了轨道，而船长却认为飞船几乎是沿着直线在前进，没有偏离目标。这场争论几乎在一瞬间就发展到高潮，船上的乘客全部醒来，纷纷加入争辩中。<br>　　尼古拉理解它们为何如此焦急。尽管出生在文明网的圈子里，但尼古拉研究过很多古代种族以及他们试图穿越宇宙的种种尝试——在宇宙中，如果你没有对准“目标”，那么你就“什么”也没有对准。任何做常规飞行的飞船携带的物资都是有限的，一般来说，几乎就刚够抵达目标。而一旦你偏离航线——等到察觉，或许需要几千亿秒来修正你的错误，或者，走一条比这更远的路去下一个目标。下地狱只需一秒，欢迎光临。<br>　　好多种族都灭绝在偏离航道上。“能回到窝的蚂蚁从来都不是大多数。”<br>　　简短的争论之后，它们冒险释放出开拓者号。在一片没有星图、没有参照星体的陌生空间中释放小飞船十分危险，如果稍有不慎，开拓者号连回到母船的机会都没有。<br>　　“兹……但是连续星图定位表明，作为第二参照物的H-η1117星系和第三参照物的独角星一直准确地停留在航行图预定位置上……主参照物肯定出了问题……”<br>　　“根据三比一原则……航行电脑可以判定哪个方位是正确的……既然……”<br>　　“那为什么我们会被航行电脑提前唤醒？”<br>　　“我不能……兹……如果航行电脑判断这条航向正确……”<br>　　“……格罗夫……后面，殖民2号已经发射……他们的补给比我们还少，人员是我们的10倍……兹……如果我们带错路……兹……”<br>　　这后面是一连串电磁爆音，许多细节湮没在干扰信号中。等到信号恢复，已经是1000秒之后的事了——他已经烧掉了“下流胚子吧”的总保险，不得不流浪到他不喜欢的“老实水手吧”来。<br>现在，他重新找回了频率。但信息是那么模糊，在中断信息的770亿秒中，孤零零悬于辽阔深空的达·伽马号到底发生了什么？停留在暗星轨道上，却失去与行星一切联系的莆田2号港口、殖民2号飞船又发生了什么？尼古拉研究过星图，“它们”提到的大裂谷，其实是一条位于旋臂чш-4971与次级旋臂чфю1277之间的空间鸿沟。暗星位于чш-4971的外缘，如果走投无路的殖民者想要回到资源丰富的银河内部，最近——也是最空旷的——道路就是直接穿越大裂谷。</p><p>　　拉修姆星就位于大裂谷东端，收到这一连串信息，也许并不是偶然。<br>　　尼古拉把时空泡开回现实时空，向总台要了一杯饮料。他安静地坐在座位上，端着杯子。银河中大多数种族，都是靠身体的虹吸管直接吸食流体的，就像Tasha尘埃云永无止境地吞噬着围绕双星的水云气那样，只有拉修姆人保持了一种怪异的方式，用容器盛水，然后用并不那么合适的嘴饮下。<br>　　现在，能否收到信息是一种赌博，与时间的赌博。根据“时空镝归原理”，某一固定时空泡不能够在一条固定的时空轨道上反复来回。时空是一种类似于面包般的固化物，穿越时空的努力，就像用一根针深深地插入时空面包，让它变形——时空“讨厌”这种变形，它会改变，以求维持时空的“惯性”。如果某个时空泡不断地“插进”某段时空，时空相对它而言就会收缩，最后还原成一个闭合环。换句话说，如果尼古拉不选择合适的插入点，而是任意挥霍他在这段时空上有限的插入次数的话，用不了多久，他本人就不能再返回这段时空，从而永远失去找到那个种族下落的机会。<br>　　在最后一条信息中，“它们”提到了某个星环——<br>　　“达·伽马号，我们距离……大约11000光秒——我们能看见通道，前导火箭开辟的道路非常清晰……星环在我们6-2方位大约3000光秒……”<br>　　?“达·伽马号，我们能看见。非常清楚。我们能穿过星环。”<br>　　“开拓者1号……开拓者……信……开拓者1号！刚才的通信中断是怎么回事？开拓者1号，请回答！”<br>　　尼古拉叹了口气，联结上银河文明网，开始搜索大裂谷。<br>　　大裂谷是银河中一片孤寂空旷的荒野，几乎没有星系，只有一些奇怪的星体和暗星体。这些非恒星物质是怎么来到荒野中的，就连高度发达的银河文明都不能解释，也许它们只是一些被某种原因抛出自己星系的宇宙流浪者，然后被大裂谷中那片“绝对黑暗”物质所俘虏……这只是一种猜测。关于那“绝对黑暗”，银河文明已经争论了很久，目前所知的是：一、那里有东西；二、那东西完全不能被任何探测仪发现；三、发现这东西的唯一办法，就是冒险做穿越大裂谷的次空间跳跃，然后变成别人眼中一道闪了一下就消失的光……<br>　　到目前为止，“绝对黑暗”只对次空间跳跃的东西产生威胁，换句话讲，它就好像是大裂谷悬挂的一道“此地禁止跳跃”的交通警示牌。银河文明很快就接受了这种警告。反正，大裂谷毫无价值，谁也没闲心花2000亿秒去穿越它，看个究竟。<br>　　“它们”正在穿越它的道路上。最后结局如何？尼古拉需要列出一张计划表，在时空镝归之前，他也许只剩下三四次空间跳跃的机会。<br>　　饮料喝完，他作出了决定。与其盲目地搜索时空，倒不如紧紧跟上“它们”的步伐。大裂谷中拥有星环的宇宙天体只有三个：红色巨星Sislan（这是颗已经死亡的恒星，可能是被某个超新星放逐到这里的残骸）、蓝色巨星Erlen’rad（它几乎不发光，但其剧烈翻滚的双层表面产生的强磁场让星球表面布满强电流，发出微微蓝光）、行星Balard（一颗石头）。三个星体分布在大裂谷中相距遥远的角落，无线电传递到拉修姆的时间相差上百亿秒。<br>　　“它们”会去恒星，还是去行星？<br>　　尼古拉把接收器对准行星Balard，时间是——1100亿秒之后。他停下时空泡，静静等待。过了很久，接收器里连该频道产生的“微能量泄露辐射背景音”都没有听到。尼古拉心里一凉，难道“它们”竟然会去到恒星的星环？<br>　　机会已经浪费一次了。他调整时空泡时脑子都紧得发战。1007亿秒后——从Sislan传来的电磁波即将抵达拉修姆。一阵沉默后，突然，传来了电磁波的微响。<br>　　“兹……兹兹……”<br>　　“兹……达·伽马……我们已经……穿越星环……红巨星……”<br>　　“开拓者……兹……”<br>　　“达……兹……我不知道该怎么解释……你们不能相信……”<br>　　“开拓者……发生什么事了？你们的飞行曲线很危险……会正面撞上红巨星……开拓者……”<br>　　“不！我们航向正确……我想是正确的……达·伽马……我们将迎上红巨星……”<br>　　“开拓者！你们疯了！”<br>　　“达·伽马号……红巨星没有重力偏移，重复一遍，在我们的坐标上没有重力偏移……”<br>　　“那并不代表红巨星不存在！……兹……红巨星的引力扭曲场可能在另一个维度……我们现在不是20世纪……不要相信直观的……兹兹……”<br>　　“达·伽马……我们正在冲向红巨星……必须要作出尝试，否则跟在身后的殖民2号就全完了……我们宁可……兹……我们正在下降……下降……距离红巨星2光秒！”<br>　　“阿列克斯！不……不！”<br>　　尼古拉闭上眼睛，等着从频道里传来船长绝望的声音。开拓者号是达·伽马的前导船，而达·伽马是从暗星逃出来的殖民2号的前导船。暗星已经坠落，如果这批人失去目标，那可就一切都完了。<br>　　几千秒后——达·伽马号的舰桥已经变成疯狂和崩溃的地狱——重新响起了声音。<br>　　“达·伽马号……伽玛号……这里是开拓者号……听到请回答……我们在一片虚空中向你们喊话……”<br>　　“……”<br>　　“达·伽马号……你们在那里吗？或者我们已经不在原来的宇宙……我们不清楚现在在什么地方……达·伽马号……但是坐标显示我们就在红巨星的核心……”<br>　　“……”<br>　　“达·伽马号……30秒之后，我们将向空间发射一次电磁脉冲……如果你们能接收到，表明我们还位于同一维度……倒计时13，12……1……”<br>　　尼古拉点起的烟，在黑暗中发出微光。前·拉修姆文明留下的为数不多的习惯，就是在烦恼时在嘴边点上一根燃烧的棍子，然后位于大脑前额的主处理芯片会让身体里所有躁动的细胞都安静下来。<br>　　此时此刻在距离他数亿光秒之远、数千亿秒之前，达·伽马号先导飞船上，一定有人和他一样，在用嘴嘬着什么。等待命运现出真容的时刻，总是如此煎熬。<br>　　“……开拓者！我们收到你们发回的信号！清晰可见！……兹……对你们的定位已经完成！你们……你们……你们在航向上……红巨星在哪里？！”<br>　　“达·伽马，这里没有红巨星，重复，没有红巨星……兹……我们周围都是影像……难以置信……红得耀眼……我不知道该怎么形容……我们看不见星空……一切都被红巨星吞没了……”<br>　　“开拓者！请你确认你的位置！”<br>“……是的……确认信号已经发出……”<br>　　“开拓者……你们在红巨星里……我的天呐，发生了什么？……红巨星是空的？”<br>　　“……不……达·伽马……我认为这里根本没有红巨星。”<br>　　“什么！？”<br>　　“很难说得清楚……达·伽马……但是我猜测我们现在位于一个真实的宇宙投影中……我们进入红巨星中，但是周围看到的全部是扭曲的红巨星表面……无论我们飞到哪里……都只能看到红巨星的表面……围绕在我们四周……现在向你们传回影像……你能看到吗?”<br>　　“开拓者……影像很清晰……我……我们不能相信……”<br>　　“达·伽马……我们迷路了……”<br>　　尼古拉跳出座位，拨电话给大学天文台。因为这是打往“过去”的电话（此刻，尼古拉本人是在现实时间的1007亿秒后。由于在宇宙中，电磁波的速度不能超过光速，因此会出现飞船将自身发出的信号甩在身后很远的情况。几千亿秒前，达·伽马与开拓者号的通信，要花同样多的时间才能抵达拉修姆星，因此尼古拉不得不把自身传送到未来才能接收到这些信号），所以花了好长时间才接通。接电话的是他的同僚，听声音，天文台大概在举办宇宙嘉年华，尼古拉不得不把声音调小到刚好能听到的程度。<br>　　“红巨星？”<br>　　“Sislan。”<br>　　“导航星？”<br>　　“导航星？！”<br>　　“呵，别那么激动，一个天文习惯用语而已——它怎么了？”<br>　　这问题问得真好。尼古拉自己也不知道它怎么了。他斟词酌句——“它……它是空的？”<br>　　“它是空的！哈！这就是打越时电话来跟我说的事儿？特克萨斯系的Sislan是空的！真惊人！你可以把这项发现权转让给我吗？”<br>　　“听着，伙计，我不开玩笑。你知道我说的是裂谷中的那个Sislan。”<br>　　“你对星影感兴趣？”<br>　　“我不明白——”尼古拉一阵头晕。<br>　　“裂谷中的Sislan，我的老兄，是特克萨斯系的Sislan的空间投影。”<br>　　尼古拉发现自己坐牢了，时间牢笼。他已经没有更多的跳跃机会，随时可能被踢出这个时空，唯一的解决办法是不离开——直到这件事解决，或者信号彻底中断，他只能待在时空泡里等待。还好，时空泡里有点补给，有电，他就死不了。来回于各个时间穿梭，他已经搞不清楚现在的“现实时间”了。只有一点很清楚，他在“老实水手吧”账单上的数字恐怕比他旅行过的时间常数加在一起还要大了。<br>　　红巨星Sislan，是一个星影。即使天文台的家伙不给他解释，他也能大致猜出些道道。问题是，那个远在数千亿秒之前的种族显然不知道这个连尼古拉都闻所未闻的现象。它们传出的信息时断时续。达·伽马和开拓者两艘船在空间中保持了相当的距离，平行地向着银河彼岸漂去。在作出决定前，它们没有更多的能量来停止或者改变前进方向，而这个决定，将会决定数千人的生死，和一个种族能否存在下去的希望。<br>　　时间一秒秒过去，两艘飞船上的所有成员的主芯片一定都过载了（尼古拉出生时，有自己的脑子，但随即就被生物工程改造为许多块处理芯片，因此他认为宇宙中的种族都是靠脑子里的芯片运作的）。它们很快就找到了问题的原因，出在路线选择上——对于急于跨越宇宙中的一大片空地，而又缺少时间和物资的种族来说，的确没有太多选择。它们想要在最短距离内跨越大裂谷，到达次级旋臂чфю1277边缘，必须为它们飞船的导航设备寻找一颗固定的、可预算轨道的星体作为导航点。在这片空旷区域中，只有红巨星Sislan散发着数千亿光秒外都能看到的微光。<br>　　但是眼下的情况是，这颗红巨星并不在那里，而且它还会随着观察者的相对距离而在空间中发生不可思议的位移。宇宙当然无奇不有，但这次显然过头了。<br>　　它们花了几千秒时间，终于得出结论：大裂谷中，存在着某种质量巨大——也许远远超出文明人想象的物体，该物体由于过于沉重，使周围的空间向“下”陷入，最后可能被扭曲空间“包”了起来，以至于完全不能被任何探测仪器找到。但是它所扭曲的空间在宇宙中形成了某种类似“透镜”的引力场，这个引力场将遥远的另一个星系里的某个区域放大、投影到了大裂谷中。但由于红巨星是个引力透镜成像的虚影，在宇宙尺度上的多维虚影与实验室里的蜡烛光没有可相提并论之处，所以，它们即使进入了红巨星的“内部”，仍然看得见它的外表。在过去770亿秒的航行中，它们与透镜的距离一直在改变，因此焦距也在改变，航向随之改变，把它们引到了绝境。</p><p>　　好吧，宇宙开了个玩笑。它开得起，受不了的人可以自行离开宇宙。</p><p>　　不知怎么的，尼古拉有一种负罪感，好像红巨星是他安排在那里糊弄人似的。在连续追踪这个种族很多很多很多秒之后，他已经认识了其中的许多人……莆田、莆田2号、远行6号……达·伽马号、开拓者号……船长、航行长……它们挣扎了无数岁月，形单影只地穿越银河，现在，它们要被迫黯然谢幕了。<br>　　两艘飞船重新聚集到一起。无线电沉默了很久，也许将要永远沉默下去。在无边无际的宇宙中，两艘比流星还要小的飞船，没有补给，没有港口，没有家园，没有目标……周围数亿光秒内，什么都没有，只有一团影子在燃烧，在嘲笑……算了吧，很多小种族都灭绝过，很多星球都沉沦过。它们的同类，不也选择了沉沦吗？也许还生活得好好的，虽然永远失去了迈向宇宙的机会……<br>　　许多“可能”像虫子一样钻进尼古拉的主芯片中。他的逻辑单元做出推论，它们已经灭亡了。虽然这颗该死的芯片早在几亿秒前就得出了相同的结论，但这一次，尼古拉知道它是对的。<br>　　他轻轻一挺身，脱离开时空泡控制臂，准备关闭时空泡。就在这时，接收器响了起来。<br>　　“开拓者，你已脱离船坞……速度3371，方向17-37……兹……”<br>　　“达·伽马……船上一切正常……他们已经入睡……再过400秒，我也将进入沉睡，航向已经……”<br>　　尼古拉从座位上跳了起来。它们还要前行！去哪里？去哪里？！<br>　　“开拓者……兹……星图已经上传到主电脑……我们不太清楚……但这是唯一的机会……那片尘埃云正在形成新的行星……如果该星系有其他行星……无论如何……我们已经没有……兹……愿上帝保佑你，足够支撑到……”<br>　　“愿上帝保佑我们大家。我们将在沉睡中等待命运裁决。”<br>　　“而我们将为你们照亮前方……兹……我们的反应堆将在1776秒后爆炸……请将我们的位置传给殖民2号……我们将完全燃烧600秒……不太长……但足以让他们的导航器重新校正方位……”<br>　　“永别了，达·伽马！”<br>　　“永别了……”<br>　　一会儿之后。<br>　　“阿列克斯，你还在吗？”<br>　　“……兹……我在……”<br>　　“如果……请不要忘记我们……”<br>　　“忘记就是背叛，达·伽马号。”<br>400秒后，开拓者陷入了沉睡。这是它们最后的选择，不得不省下每一秒钟的补给。1776秒后，达·伽马号变成了宇宙中的一道一闪即逝的光。对于在它身后很远的地方，正沉默着前进的殖民2号而言，这道光将是黑暗星空中唯一真实的路标。<br>　　毫无疑问，接下来的很长时间里，将再也不会出现无线电信息。殖民2号与开拓者更改航向，在黑暗中飘浮，根据过往的经验，里面的生物有99.999%的可能再也醒不过来。<br>　　时空泡内的空调单调地响着。尼古拉决定不再等待下去了。在回到正常时空之前，他叹了口气，稍稍在椅子上伸了伸腰。远方，Tasha尘埃云轰轰地吸入水汽，再过很多很多很多亿秒，那里将会生成一颗行星。和宇宙无限的生命比起来，任何有机物都渺小得可笑。<br>　　也许不那么可笑……<br>　　也许这并不好笑……<br>　　也许……<br>　　也许它们说的尘埃云就是Tasha？！<br>　　尼古拉几乎是发着抖，重新启动时空泡引擎。一个一直在他面前闪烁的数字艰难地从2变到1。他的时空镝归函数满了。再经过一跳，对他而言，这段时空就将永久封闭，他再也不可能亲身来体验这段历史，寻找那些绝望或者充满希望的信息。即使他再通过时空泡进入这些“时间”，时空相对他而言也将变得寂静无趣。<br>　　时空泡操作系统默默等待使用者输入前方时间点。它等了很久，终于，使用者在“起点”一栏，输入“现实时间”。过了好一会儿，他才在“终点”一栏，输入——1800亿秒前（此处的1800亿秒前亦是以现实时间为基础的，读者可以自己想一下原因）。<br>　　Tasha沉重的身躯转动起来，越转越快……宇宙翻过来倒过去，星潮漫过拉修姆，璀璨不可逼视，然后慢慢褪去。<br>　　星空在1800亿秒前注视着尼古拉。他松开控制臂，站起来，走向窗前。<br>　　拉修姆在身下很远的地方。那时候，它还处于蒙昧中。没有建筑，没有灯光，没有穿梭往来的时空舰队。时空泡像个幽灵，飘浮在其上方几千里的空间中。<br>　　接收器“咯吱咯吱”地响着。静电噪声飘过空间。<br>　　不知道过了多少时候，突然——<br>　　“……兹……这里是殖民2号……兹……达·伽马号……兹……开拓者……兹兹……”<br>　　尼古拉觉得自己背上的毛都立起来了。<br>　　“……达·伽马……我们收不到你们的信号……兹……我们无法精确定位……我们能够看到……目标行星很清晰……开拓者……你们在哪里？你们已经登陆了……你们能看到我们吗……兹……呼叫达·伽马号……”<br>　　现在，不需要借助任何仪器，在Tasha左面偏下的位置，一个闪闪发亮的点已经清晰可辨，那是某种低级空间推进器在脱离光速时产生的火焰。<br>　　在经历了数千亿光秒的近乎自杀般的旅程之后，达·伽马用生命指引的殖民2号终于抵达了目的地。那艘飞船已被时间和空间折磨得支离破碎，它摇摇摆摆地晃动着，目标已经近在咫尺，但脱离光速带来的冲击也让它一秒比一秒更加虚弱。<br>　　数百秒后，殖民2号爆发出一连串闪光。<br>　　“……兹……达·伽马号……我们出了一些故障……现在不清楚……我看见一些舱体离开飞船……达·伽马号！开拓者号……我们出问题了……飞船抖动得很厉害……我们不知道……”<br>　　那颗光点在空间留下许多烟和亮晶晶的碎屑，然后一头扎向拉修姆星的轨道，站在6万公尺的上空，那飞船几乎是从尼古拉脚底掠过。他能看见那些伤痕累累的船体和早已歪斜的舰桥。一大半的飞船都裹在浓烟中。<br>　　“……有谁在那里……帮帮我们！帮帮我们……大部分乘客还没有苏醒……达·伽马号……谁在那里？请帮帮我们！”<br>　　尼古拉发疯般地从窗口这一头冲到那一头，但是隔着玻璃与时间的双重厚壁，他只能眼睁睁地看着飞船转到地平线的另一头去。频道里的惊叫声越来越大。<br>　　“警报！警报！主引擎熄火了！我们正在失去动力……失去动力！”<br>　　“减速失败！减速失败！”<br>　　“速度在上升……我们要坠毁了！”<br>　　“稳住船体！”<br>　　“……第四舱的火势无法控制了……正在蔓延，正在蔓延！”<br>　　“船长室！我是第四舱！立刻放弃我们！放弃我们！”<br>　　“……第四舱剥离……第四舱坠毁……”<br>　　“控制不住了！”<br>　　“船长室！火势蔓延过中舱！”<br>　　“我们失去了870人！”<br>　　“船长室！如果不改出，还有150秒就要撞击坠毁！”<br>　　飞船裹着熊熊大火从地平线的另一端冒了出来。尼古拉捂紧嘴巴。历史第一次在眼前历历上演，演员是一群经过了几代人努力、几千亿秒跋涉、从深沉的梦中惊醒的孤立无助的人。宇宙无视这些镶嵌在历史中的悲惨镜头。<br>　　“这里是船长室……殖民2号的全体船员……我们只剩下一个办法……只有一次机会……我们剩下的能量只够发射一个舱室，并让它安全降落……船员们……我们时间不多……需要立刻决定发射哪一个舱室……”<br>　　“第七舱室，船长！”<br>　　从即将坠毁飞船的各个角落传出隐约的声音。<br>　　“太好了。第七舱室是妇女和儿童。”<br>　　“但是……他们中间没有专业人员……如果我们坠毁……将来他们怎么生存下去？”<br>　　“只要延续，就有办法。”<br>　　各个舱室——数量更少了。几十秒之内，许多舱室都已失去了声音——传来赞同声。<br>　　“发射准备！”<br>　　“舱室封闭！”<br>　　“再见了，阿丽娜！”<br>　　“发射完毕！”<br>　　一个光球脱离飞船，笔直地向下坠落。飞船继续一圈一圈地绕着小行星飞行。大火已经将它完全吞没，可是从里面传出的声音却仍不绝于耳。<br>　　“舱室进入大气层！”<br>　　“飞行姿态正常！”<br>　　“减速伞打开……速度降下来了！”<br>　　“万岁！舱室将安全着陆！”<br>　　最后一句话，只有少数几个人响应。其他人都已消失在大火之中。<br>　　“……这是殖民2号在呼唤……达·伽马……开拓者……你们在听吗？我们已经按照与你们的约定，在不知名的行星上播下了种子……感谢你们……我们不知道你们去了哪里……不过没关系……阿列克斯……我们曾经失去过……我们曾经流浪过……我们曾经放弃过……”<br>　　“但我们终将找到家园。”<br>　　从宇宙的角度来观看，这场大火是不存在的。然而电波刺破苍穹，坚定地向着遥远的未来前进。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科幻小说 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
